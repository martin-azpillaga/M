(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{379:function(e,t,a){"use strict";a.r(t);var i=a(42),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"animation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#animation"}},[e._v("#")]),e._v(" Animation")]),e._v(" "),a("p",[e._v("Animation refers to modifying the data of your simulation depending on the time.\nAn animation is anything related to time. This is useful for creating timers,\nsprite animations, mesh animations and cut scenes.")]),e._v(" "),a("h2",{attrs:{id:"timers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#timers"}},[e._v("#")]),e._v(" Timers")]),e._v(" "),a("p",[e._v("Three magic components define timer behavior:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("XElapsed: Every elapsed component will get its value increased by deltaTime\neveryFrame.")])]),e._v(" "),a("li",[a("p",[e._v("X: If an entity has both XElapsed and X, the elapsed component will restart\nwhen it's value is larger than X's.")])]),e._v(" "),a("li",[a("p",[e._v("XTimeout: If an entity has XElapsed, X and XTimeout, XTimeout will be true in\nthe frames where the elapsed time has restarted.")])])]),e._v(" "),a("h2",{attrs:{id:"sprite-animations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sprite-animations"}},[e._v("#")]),e._v(" Sprite animations")]),e._v(" "),a("p",[e._v("Work in progress.")]),e._v(" "),a("h2",{attrs:{id:"mesh-animations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mesh-animations"}},[e._v("#")]),e._v(" Mesh animations")]),e._v(" "),a("p",[e._v("Work in progress.")])])}),[],!1,null,null,null);t.default=s.exports}}]);