grammar source.CSharp with source.Modular hidden(WS, MULTIPLE_LINES_COMMENT, SINGLE_LINE_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.minim.games/modular"
generate csharp "http://www.minim.games/csharp"

Model:
	usings+=Using*
	types+=Type*;

Using:
	'using' name=QualifiedName ';';

Type:
	{Type}
	annotations+=Annotation*
	visibility=Visibility?
	(({Struct.info=current} 'struct' name=TYPENAME
	|
	{Class.info=current} sealed?='sealed'? static?='static'? 'class' name=TYPENAME)
	(':' superTypes+=TYPENAME (SEPARATOR superTypes+=TYPENAME)*)?
	BEGIN members+=Member* END
	|
	{Enum.info=current}
	'enum' name=TYPENAME
	BEGIN (values+=IDENTIFIER (SEPARATOR values+=IDENTIFIER)*)? END);

Info:
	Member | Type;

Member:
	{Member}
	annotations+=Annotation*
	visibility=Visibility?
	(({Struct.info=current} 'struct' name=TYPENAME
	|
	{Class.info=current} static?='static'? 'class' name=TYPENAME)
	(':' superTypes+=TYPENAME (SEPARATOR superTypes+=TYPENAME)*)?
	BEGIN members+=Member* END
	|
	{Enum.info=current}
	'enum' name=TYPENAME
	BEGIN (value+=IDENTIFIER (SEPARATOR values+=IDENTIFIER)*)? END
	|
	(({Method.info=current} override?='override')?
	({Method.info=current} static?='static')?
	type=TYPENAME
	({Field.info=current} name=IDENTIFIER ';'
	|
	{Method.info=current} name=TYPENAME OPEN (arguments+=Argument (SEPARATOR arguments+=Argument)*)? CLOSE
	BEGIN
	statements+=Statement*
	END)));

enum Visibility:
	public | protected | private;

@Override
Expression:
	Ternary ({InlineAssignment.left=current} kind=AssignmentKind right=Ternary)*;

@Override
UnaryMinus returns Expression:
	UnaryPlus | {UnaryMinus} '-' expression=UnaryPlus;

UnaryPlus returns Expression:
	PreDecrement | {UnaryPlus} '+' expression=PreDecrement;

PreDecrement returns Expression:
	PreIncrement | {PreDecrement} '--' expression=PreIncrement;

PreIncrement returns Expression:
	Primary | {PreIncrement} '++' expression=Primary;

@Override
Statement:
	Selection | Iteration | Call | Assignment | For | Declaration | Return;

@Override
Iteration:
	'while' OPEN condition=Expression CLOSE
	BEGIN statements+=Statement* END;

@Override
Selection:
	'if' branches+=Branch
	('else' 'if' branches+=Branch)*
	('else' BEGIN statements+=Statement* END)?;

@Override
Branch:
	OPEN condition=Expression CLOSE
	BEGIN statements+=Statement* END;

For:
	'for' OPEN initialization=Assignment ';' condition=Expression ';' increment=Assignment CLOSE
	BEGIN
	statements+=Statement*
	END;

Return:
	'return' expression=Expression ';';

Declaration:
	(var?='var' | type=TYPENAME) access=ACCESS 
	(assignmentType=AssignmentKind expression=Expression)? ';';
	
@Override
Assignment:
	identifier=ACCESS kind=AssignmentKind expression=Expression ';'
;

@Override
Call:
	identifier=IDENTIFIER
	OPEN (parameters+=Expression (SEPARATOR parameters+=Expression)*)? CLOSE ';';

@Override
IdentifierLiteral:
	value=ACCESS;

Annotation:
	'[' call=Call ']';

Argument:
	annotations+=Annotation* ref?='ref'? type=TYPENAME name=IDENTIFIER;

Lambda: {Lambda}
	OPEN (arguments+=Argument (SEPARATOR arguments+=Argument)*)? CLOSE '=>' BEGIN statements+=Statement* END;

Index: identifier=IDENTIFIER  '[' (parameters+=Expression ( SEPARATOR parameters+=Expression)*)?  ']';

@Override
Variable: IdentifierLiteral|Call|Index;

ACCESS:
	IDENTIFIER ('.' IDENTIFIER)*;

QualifiedName:
	IDENTIFIER ('.' IDENTIFIER)*;

TYPENAME:
	IDENTIFIER ('<' TYPENAME (SEPARATOR TYPENAME)* '>')?;

terminal MULTIPLE_LINES_COMMENT:
	'/*'->'*/';

terminal SINGLE_LINE_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;
 