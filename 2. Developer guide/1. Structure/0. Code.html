<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Source code | Project M</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="A data-driven programming language for game developers">
    <link rel="preload" href="/assets/css/0.styles.7f79b7ea.css" as="style"><link rel="preload" href="/assets/js/app.58246eed.js" as="script"><link rel="preload" href="/assets/js/2.09ea20ae.js" as="script"><link rel="preload" href="/assets/js/29.0535ec86.js" as="script"><link rel="prefetch" href="/assets/js/10.a00b7967.js"><link rel="prefetch" href="/assets/js/11.b8065b65.js"><link rel="prefetch" href="/assets/js/12.0dde2e9e.js"><link rel="prefetch" href="/assets/js/13.0dc88554.js"><link rel="prefetch" href="/assets/js/14.22220a83.js"><link rel="prefetch" href="/assets/js/15.b9fdfd33.js"><link rel="prefetch" href="/assets/js/16.419d6364.js"><link rel="prefetch" href="/assets/js/17.5072f7ae.js"><link rel="prefetch" href="/assets/js/18.16f41493.js"><link rel="prefetch" href="/assets/js/19.60763de3.js"><link rel="prefetch" href="/assets/js/20.34b1af12.js"><link rel="prefetch" href="/assets/js/21.eb91a2a5.js"><link rel="prefetch" href="/assets/js/22.c63b1308.js"><link rel="prefetch" href="/assets/js/23.80f7ad8f.js"><link rel="prefetch" href="/assets/js/24.58e60bd0.js"><link rel="prefetch" href="/assets/js/25.46eb3096.js"><link rel="prefetch" href="/assets/js/26.ea6096ae.js"><link rel="prefetch" href="/assets/js/27.b84010f6.js"><link rel="prefetch" href="/assets/js/28.61bc8a4c.js"><link rel="prefetch" href="/assets/js/3.0becae8a.js"><link rel="prefetch" href="/assets/js/30.d3b26fe6.js"><link rel="prefetch" href="/assets/js/31.c3b5360b.js"><link rel="prefetch" href="/assets/js/32.47d75025.js"><link rel="prefetch" href="/assets/js/33.46f5dd44.js"><link rel="prefetch" href="/assets/js/34.1b7b5a7c.js"><link rel="prefetch" href="/assets/js/35.ec2b612e.js"><link rel="prefetch" href="/assets/js/36.2d035c9e.js"><link rel="prefetch" href="/assets/js/37.a14945ab.js"><link rel="prefetch" href="/assets/js/38.52da2884.js"><link rel="prefetch" href="/assets/js/4.6d883f6b.js"><link rel="prefetch" href="/assets/js/5.71922889.js"><link rel="prefetch" href="/assets/js/6.339d378f.js"><link rel="prefetch" href="/assets/js/7.79b10682.js"><link rel="prefetch" href="/assets/js/8.439e8c27.js"><link rel="prefetch" href="/assets/js/9.185dea49.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f79b7ea.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://avatars2.githubusercontent.com/u/6147446?s=400&amp;u=c325f5bfc187e889f05cc872681ad1cb1ba6b3b5&amp;v=4" alt="Project M" class="logo"> <span class="site-name can-hide">Project M</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/0. Starter guide/0. Set up.html" class="nav-link">
  Starter guide
</a></div><div class="nav-item"><a href="/1. User guide/0. How to/0. Transforms.html" class="nav-link">
  User guide
</a></div><div class="nav-item"><a href="/2. Developer guide/0. Philosophy/0. Motivation.html" class="nav-link">
  Developer guide
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/0. Starter guide/0. Set up.html" class="nav-link">
  Starter guide
</a></div><div class="nav-item"><a href="/1. User guide/0. How to/0. Transforms.html" class="nav-link">
  User guide
</a></div><div class="nav-item"><a href="/2. Developer guide/0. Philosophy/0. Motivation.html" class="nav-link">
  Developer guide
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/2. Developer guide/0. Philosophy/0. Motivation.html" class="sidebar-link">Language properties</a></li><li><a href="/2. Developer guide/0. Philosophy/2. Design decisions.html" class="sidebar-link">Design decisions</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="source-code"><a href="#source-code" class="header-anchor">#</a> Source code</h1> <p>Under 100 files (54). Under 10k lines of code (7k). No comments (0). The code
for the language server relies on the Xtext framework. It consists of two
projects, m and m.ide. The project m holds all the information for running the
compiler in headless mode. This includes the grammar specifying the lexer and
parser rules, the validator, formatter, linker and code generators. In fact, m
consists of 7 languages and translations, one for each kind of supported file
type. A language for JSON, XML, YAML, C#, and of course M and all its variants
in different natural languages. Google's Guice dependency injection framework
wires every component of the language. The IDE components like code completion,
syntax highlighting, labels, quick fixes, outline view are in the m.ide project
independently from the execution platform. It's useful to have a m.ui project to
test the functionality in a eclipse instance with a debugger attached to it.</p> <p>Single sourcing: If certain code's structure logically depends on another code,
it should get automatically generated. Example: Blockly block definitions depend
on the grammars rules. Block definition files are automatically generated based
on the grammars.</p> <p>Parser: Terminals are single character and pairwise disjoint. Don't use hidden
terminals. Don't use until token. Don't use syntactic predicates. Don't use
backtracking. DataTypes combine terminals in the least information needed.
Expressions follow Xtext guidelines for associativity and precedence. Full
support for c# expressions in the base grammar. M grammar can override a rule to
skip certain operators from the language. Unary minus operand acts on floats to
make them negative (otherwise they are alway positive). Numbers in components
can be negative because they use a different datatype rule which can include a
minus sign (NUMBER vs FLOAT).</p> <p>m/src</p> <p>Generate.java: This main java file generates all the xtext infrastructure from
the grammar files. To generate all the project files, first execute this main
file. It will generate a bunch of files under m/src, m/src-gen, m.ide/src and
m.ide/src-gen. It also generates a m.ui project to faster test the language
server inside an eclipse application. The easiest way to use eclipse with this
project is to create a xtext project with the name m first with generic ide and
eclipse plugin options selected, then download the project files to possibly
override the existing ones. Execute generate.java as a java application and your
eclipse project will be ready.</p> <p>xRuntimeModule: Dependency injection wiring via Google guice modules. If the
injection is already wired in AbstractLanguageRuntimeModule, the injection needs
to be overridden, if it's not it must use def. Xtext has syntax sugar def
bindIService(){ ClassName } OutputConfiguration is an example.</p> <p>x.xtext: Grammar definitions. All independent. Limit terminals. More data rules
and lastly parser rules. no backtracking, no semantic helpers.</p> <p>converter/MyTerminalConverter: Used when terminal rules return something other
than a EString. Defines how the conversion works in both directions.</p> <p>errorHandling/XSyntaxErrorMessageProvider: Used when the parser throws an error
to improve the error message considering the context.</p> <p>xFormatter: dispatched functions to add white spaces when serializing a model.
AAlways try to use prepend to avoid conflicts, use grammar access to access
non-keywords. Use literal keywords like ',' instead of grammarAccess ones for
better maintainability.</p> <p>LanguageGenerator:</p> <p>Main.java: For headless execution. Depends on java JRE and the JAR built. Give
it a file and it will parse it and generate it for you.</p> <p>transformation: Each file is responsible of generating all files of a specific
kind. First the type inference runs and now with the model and the types
inferred the generator can generate all the artifacts. BuiltInLibrary translates
names of built-in components for generating the same text in other languages.
Some are legacy code. The ones that uses TextGenerator matter.</p> <p>No hybrid or pure distinction, use Hybrid.Rendering, Unity.Physics etc when
they are ready and do the rest in Hybrid, as any professional would do
nowadays.</p> <p>UnityGenerator UnityParser BlockGenerator BlockParser</p> <p>xValidator: Rules to make extra assumptions true in the model. For example
unique names.</p> <p>Workflow.mwe2: Important. Generates all the artifacts. It defines the project
structure and the fragments that each language cares about.</p> <p>ide:</p> <p>MyContentAssist extends IdeContentProposalProvider: For platform agnostic
definition of content assist proposals.</p> <p>MyLabelProvider extends SimpleNameLabelProvider: For platform agnostic
definition of label names.</p> <p>build.gradle: Gradle script to build the language server. It needs the reference
to the mwe workflow file and it passes it the rootPath variable. It runs the
workflow and generates a language server fat jar file in build folder.</p> <h2 id="generating-xtext-artifacts"><a href="#generating-xtext-artifacts" class="header-anchor">#</a> Generating Xtext artifacts</h2> <p>The first step to build the project is to generate all the xtext artifacts. The
RunFragments.java file creates a xtext generator workflow and adds a standard
language to it for each grammar file located in the m/src/m folder.</p> <p>The standard languages include built in fragments to generate the grammar
access, parser, emf model, generators, serializer etc. To all this we add a
custom fragment called ContextualParserMessagesFragment which wires the
ContextualParserMessages as the responsible for producing error messages when
the parser finds one.</p> <p>When we run the workflow, the generated dependency injection injectors
AbstractXRuntimeModule.java wire all the fragments together. In particular, they
wire the ISyntaxErrorMessageProvider interface to ContextualParserMessages.</p> <h2 id="using-gradle"><a href="#using-gradle" class="header-anchor">#</a> Using gradle</h2> <p>The build.gradle file defines two gradle tasks:</p> <ul><li>runFragments: Runs the m.main.RunFragments.java file with the correct
dependencies to generate the xtext artifacts.</li> <li>generateLanguageServer: Packages all the generated .class files and the
dependencies in a fat jar file.</li></ul> <h2 id="folder-structure"><a href="#folder-structure" class="header-anchor">#</a> Folder structure</h2> <p>The project has three root folders:</p> <ul><li><p>.github: Contains all the automation tasks and their configuration files.</p></li> <li><p>Code: Contains all the java files and xtext grammars used to describe the
language server and client.</p></li> <li><p>Documentation: Contains all the markdown files that explain the reasoning
behind the code.</p></li></ul> <h2 id="validation"><a href="#validation" class="header-anchor">#</a> Validation</h2> <p>There are three main types of checks:</p> <ul><li><p>Uniqueness checks: Makes sure that there is a single element in the container
with that specific name. Examples: unique component, unique entity, unique
system. Included checks: Unique component name in entity, Unique entity name
in module, Unique system name in module, Unique procedure name in module,
Unique tag name in loop tags, Unique argument name in procedure.</p></li> <li><p>Existence checks: Makes sure that the specified cross reference exists.
Examples: function call name exists, base of an entity exists. Included
checks: The base of an entity exists in the module, The entity accessed in a
variable exists in a previous assignment or loop statement.</p></li> <li><p>Acyclic checks: Makes sure that the dependencies are not cyclic. That means,
if A depends on B, B can not depend on A etc. Examples: entity A has base B,
entity B can not have base A. Similarly for 3-cycles and n-cycles. A depends
on B, B depends on C, C can not depend on A. Included checks: The base of an
entity is acyclic.</p></li> <li><p>Typing checks: Makes sure that the variables have conformable types. Examples:
Engine components have the correct type (Position must be a Float3 etc),
Custom vector components have up to four entries, the left and right
expressions in an addition have the same type.</p></li></ul> <h2 id="parsing-error-messages"><a href="#parsing-error-messages" class="header-anchor">#</a> Parsing error messages</h2> <p>The ContextualParserMessagesFragment deduces parser error messages from the
grammar definition. When there is an error, it walks the grammar structure to
find the feature that is missing, considering all the possible alternatives and
creates a one line message for each alternative.</p> <p>For example, under the input</p> <div class="language-{.set .parser1 .main.m} extra-class"><pre class="language-text"><code>entity : ?
</code></pre></div><p>It gives the error message</p> <div class="language-{.check .parser1 .error} extra-class"><pre class="language-text"><code>Parser error at ?
Write WORD to set the base of the Entity
</code></pre></div><h2 id="unity-components"><a href="#unity-components" class="header-anchor">#</a> Unity components</h2> <p>Four kind of components represent the data:</p> <ul><li><p>Value components: They are IComponentData with automatically generated
authoring components. Example: mass.</p></li> <li><p>List components: They are IBufferElementData with custom authoring component
that converts game object references to entities.</p></li> <li><p>Reference components: They are class IComponentData with custom authoring
component that adds a componentObject to the entity.</p></li> <li><p>Engine components: They are UnityEngine classes that get added to entities by
the EngineComponentConversion system.</p></li></ul> <h2 id="workflow"><a href="#workflow" class="header-anchor">#</a> Workflow</h2> <p>M operates in four stages: Parsing, validating, generating and formatting.</p> <p>The parser processes the input given by the user and checks for syntactical
errors. The result is an abstract syntax tree containing all the essential
information of the file, all the data without white spaces.</p> <p>The validator checks the information of the abstract tree for semantic validity.
The result is an Eclipse Modeling Framework model of the abstract representation
of the interactive simulation.</p> <p>The generating represents the model in all the requested platforms, including
textual representations in different languages, visual representations in
different languages and project representations in different game engines. The
result is a folder with all the required files for representing that simulation
in each platform.</p> <p>The formatter mixes white space with the generated text so that humans can
understand it.</p> <h2 id="for-each-view"><a href="#for-each-view" class="header-anchor">#</a> For each view</h2> <p>M has three main views: Textual, Visual and Project. These might appear
translated to different natural languages. For instance, English, Spanish and
Basque. The total number of combinations is the product of views by
translations.</p> <h2 id="language-syntax"><a href="#language-syntax" class="header-anchor">#</a> Language syntax</h2> <p>Allow not recommended constructions like single line comments, multi line
comments, number and string literals in systems... but warn them as deprecated.
This way, coders are not confused but directed in the &quot;right&quot; direction, and
after adoption, the language will enforce stronger rules.</p> <p>M has a C-style syntax, like C++, Java or C#. It build on the same idea of
expression and control flows like iteration and branching blocks but differs on
the higher level abstractions. M does not contain any object oriented concepts
like classes or visibility modifiers. Neither has the ability to specify new
data structures, enumerations or similar in C. Instead it provides two simple
and powerful abstractions: Entities and systems.</p> <p>Two root level concepts in M: Entities and systems. In fact, every program
written in M consists solely of entities and systems. The components of entities
hold all the data of the program while systems hold the interactions.</p> <p>Entities have a name and a list of components. Each component holds a single
value which might be a vector or an asset. Vectors store numeric values such as
mass, position or rotation. They can have up to four dimensions. Assets are a
sequence of words of arbitrary length. The type inference system will decide
which kind of asset - mesh, image, audio clip, font... - based on the usage of
the component.</p> <p>Systems consist of a unique name and a list of sequential commands. These
command can be blocks such as loops or branches that might in turn contain more
commands themselves.</p> <p>Four kinds of commands. Loops iterate over entities with a certain constraints,
branch commands take different paths depending of a condition. Repeat commands
repeat their body a set number of times. Assignments assign a value to a
variable or a component. Call commands call a function that is either built in
or defined by the user.</p> <p>The expressions of the language consist of boolean and arithmetic expressions.
Arithmetic expressions can use operands like +,-,*,/,% and the bitwise
&amp;,|,&lt;&lt;,&gt;&gt;,^,~ to alter numerical values. The types of the operands must be
compatible with the operation. The bitwise operators work over single dimension
vectors (scalars). The multiplicative operations *,/,% can take any vector as
first argument but a scalar as a second argument. The additive operations + and
- accept any two vectors as long as their dimensions are equal.</p> <p>And that's it. You can build more complex abstractions by combining these basic
concepts. You can watch some of these in action in the <a href="/0. Beginner guide/2. Guided examples/">examples</a> documentation.</p> <h2 id="keywords"><a href="#keywords" class="header-anchor">#</a> Keywords</h2> <p>The grammar has some words reserved that can't be identifiers. The list of all
identifiers is:</p> <div class="language-m extra-class"><pre class="language-text"><code>foreach, with, if, else
</code></pre></div><p>You can use any other word for your identifiers as long as it starts with an
underscore or letter followed by any amount of letters and numbers.</p> <div class="language-m extra-class"><pre class="language-text"><code>Identifier: '_'? ('a'..'z'|'A'..'Z'|'0'..'9')+
</code></pre></div><p>White space. The parser of M ignores all the white space. You can structure your
code as you want using white space. We recommend using the built in formatter
for consistency across team members and easier version controlling.</p> <div class="language-m extra-class"><pre class="language-text"><code>Whitespace: '\n'|'\r'|' '|'\t'
</code></pre></div><p>Sometimes, the next token must be a number.</p> <div class="language-m extra-class"><pre class="language-text"><code>Number: '-'? DIGIT* ('.' DIGIT+ ('e' '-'? DIGIT+)?)?
DIGIT: '0'..'9'
</code></pre></div><h2 id="data-oriented-design"><a href="#data-oriented-design" class="header-anchor">#</a> Data oriented design</h2> <p>Everything is data. Introducing the data model:</p> <p>The data matrix and the variable heap hold all the data of a frame of a game.</p> <p>Our job as programmers is to define the laws that transform this data every
frame.</p> <p>The possible ways to alter the data are:</p> <ul><li><p>Create a new row in the matrix (Entity creation)</p></li> <li><p>Delete a row in the matrix (Entity deletion)</p></li> <li><p>Activate a cell in the matrix (Component addition)</p></li> <li><p>Deactivate a cell in the matrix (Component removal)</p></li></ul> <p>We can use the variable heap to store temporary values. The system automatically
deletes this values after every frame.</p> <ul><li>Create an entry in the heap (Variable declaration)</li></ul> <p>Now we need a way to gather values to write to the matrix cells and the heap.</p> <ul><li><p>Read a value stored in a cell (Component access)</p></li> <li><p>Read a value stored in the heap (Variable access)</p></li></ul> <p>These are the atoms of data. We can transform the data by using transformations:</p> <ul><li>Operators: Arithmetic, Comparison, Logic, Set operators</li> <li>Grouping: Join, Set creation, Brackets...</li> <li>Functions: Math functions.</li></ul> <p>Control Flow.</p> <p>We may repeat this process per matching row (Forall), while a condition is true
(Iteration) or if a condition is true (Selection).</p> <p>And that is the whole grammar of M.</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/22/2020, 2:41:04 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.58246eed.js" defer></script><script src="/assets/js/2.09ea20ae.js" defer></script><script src="/assets/js/29.0535ec86.js" defer></script>
  </body>
</html>
