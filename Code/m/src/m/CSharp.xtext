grammar m.CSharp with m.Modular hidden(WS, MULTIPLE_LINES_COMMENT, SINGLE_LINE_COMMENT)

import "azpillaga.world/modular"
generate csharp "azpillaga.world/csharp"

Model:
	usings+=Using*
	types+=Type*;

Using:
	'using' name=QualifiedName ';';

Type:
	{Type}
	annotations+=Annotation*
	visibility=Visibility?
	(({Struct.info=current} 'struct' name=TYPENAME
	|
	{Class.info=current} sealed?='sealed'? static?='static'? 'class' name=TYPENAME)
	(':' superTypes+=TYPENAME (',' superTypes+=TYPENAME)*)?
	'{' members+=Member* '}'
	|
	{Enum.info=current}
	'enum' name=TYPENAME
	'{' (values+=WORD (',' values+=WORD)*)? '}');

Info:
	Member | Type;

Member:
	{Member}
	annotations+=Annotation*
	visibility=Visibility?
	(({Struct.info=current} 'struct' name=TYPENAME
	|
	{Class.info=current} static?='static'? 'class' name=TYPENAME)
	(':' superTypes+=TYPENAME (',' superTypes+=TYPENAME)*)?
	'{' members+=Member* '}'
	|
	{Enum.info=current}
	'enum' name=TYPENAME
	'{' (value+=WORD (',' values+=WORD)*)? '}'
	|
	(({Method.info=current} override?='override')?
	({Method.info=current} static?='static')?
	type=TYPENAME
	({Field.info=current} name=WORD ';'
	|
	{Method.info=current} name=TYPENAME '(' (arguments+=Argument (',' arguments+=Argument)*)? ')'
	'{'
	statements+=Statement*
	'}')));

enum Visibility:
	public | protected | private;

@Override
Expression:
	Ternary ({InlineAssignment.left=current} kind=AssignmentKind right=Ternary)*;

@Override
UnaryMinus returns Expression:
	UnaryPlus | {UnaryMinus} '-' expression=UnaryPlus;

UnaryPlus returns Expression:
	PreDecrement | {UnaryPlus} '+' expression=PreDecrement;

PreDecrement returns Expression:
	PreIncrement | {PreDecrement} '--' expression=PreIncrement;

PreIncrement returns Expression:
	Primary | {PreIncrement} '++' expression=Primary;

@Override
Statement:
	Selection | Iteration | FunctionCall | Assignment | For | Declaration | Return;

@Override
Iteration:
	'while' '(' condition=Expression ')'
	'{' statements+=Statement* '}';

@Override
Selection:
	'if' branches+=Branch
	('else' 'if' branches+=Branch)*
	('else' branches+=DefaultBranch)?;

@Override
Branch:
	'(' condition=Expression ')'
	'{' statements+=Statement* '}';

For:
	'for' '(' initialization=Assignment ';' condition=Expression ';' increment=Assignment ')'
	'{'
	statements+=Statement*
	'}';

Return:
	'return' expression=Expression ';';

Declaration:
	(var?='var' | type=TYPENAME) variable=Variable 
	(assignmentType=AssignmentKind expression=Expression)? ';';
	
@Override
Assignment:
	variable=Variable kind=AssignmentKind expression=Expression ';'
;

@Override
FunctionCall:
	name=WORD
	'(' (parameters+=Expression (',' parameters+=Expression)*)? ')' ';';

Annotation:
	'[' call=FunctionCall ']';

Argument:
	annotations+=Annotation* ref?='ref'? type=TYPENAME name=WORD;

Lambda: {Lambda}
	'(' (arguments+=Argument (',' arguments+=Argument)*)? ')' '=>' '{' statements+=Statement* '}';

Index: identifier=WORD  '[' (parameters+=Expression ( ',' parameters+=Expression)*)?  ']';

@Override
Primary returns Expression: 
	FloatLiteral |
	StringLiteral |
	BooleanLiteral |
	Variable|
	FunctionCall|
	Index|
	'(' Expression ')'
;

QualifiedName:
	WORD ('.' WORD)*;

TYPENAME:
	WORD ('<' TYPENAME (',' TYPENAME)* '>')?;

terminal MULTIPLE_LINES_COMMENT:
	'/*'->'*/';

terminal SINGLE_LINE_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;
 