grammar m.CSharp with m.Modular hidden(WS, MULTIPLE_LINES_COMMENT, SINGLE_LINE_COMMENT)

import "azpillaga.world/modular"
generate csharp "azpillaga.world/csharp"

// => ( grammar ) significa
// Si y solo si todo de grammar esta presente, sigue por este camino
// Sino busca una alternativa
// Si y solo si!
// Si esta presente sigue por aqui pero solo si esta presente
// Ejemplo
// Si hago en Mem: =>(modifiers+=Modifier*) ...
// Si esta presente y solo si esta presente ire por este camino
// Pero esto es siempre dado que 0 modifiers siempre estaran presentes
// Ahora, si hago en Mem: =>(modifiers* type name typeparams* '(' )
// Si hayu un parentesis a la vista cogere este camino pero solo si hay un
// parentesis a la vista.
//
// El orden y los parentesis importan mucho. Ejemplo =>Field|Method no
// funciona, ni (Method|=>Field) pero (=>Field|Method) si
// Siempre poner => en la primera alternativa, reordenar para optimizar si eso

CompilationUnit:
	externAliases+=ExternAlias*
	globalAttributes+=GlobalAttribute*
	usings+=Using*
	types+=NamespaceMember*;

GlobalAttribute:
	'[' ('assembly'|'module') ':' attributes+=Attribute (',' attributes+=Attribute)* ']';

Attribute:
	name=WORD arguments=AttributeArguments?
;
AttributeArguments: {AttributeArguments}
	'(' 
	(
		positionals+=LogicalOr (',' positionals+=LogicalOr)*
		(',' named+=NamedArgument (',' named+=NamedArgument)*)?
		|
		named+=NamedArgument (',' named+=NamedArgument)*
	)?
	')'
;
NamedArgument:
	name=WORD '=' expression=Expression
;
ExternAlias:
	'extern' 'alias' name=WORD ';'
;
Using:
	AliasUsing|NamespaceUsing|StaticUsing;

AliasUsing:
	'using'
	alias=WORD '=' namespace=QUALIFIEDTYPE
	';'
;
QUALIFIEDTYPE:
	TYPE ('.' TYPE)*
	|
	WORD '::' TYPE ('.' TYPE)*
;
NamespaceUsing:
	'using'
	namespace=QUALIFIEDTYPE
	';'
;
StaticUsing:
	'using'
	'static'
	namespace=QUALIFIEDTYPE
	';'
;

Namespace:
	'namespace' qname=QUALIFIEDNAME 
	'{' 
	externAliases+=ExternAlias*
	usings+=Using*
	members+=NamespaceMember* 
	'}'
	 ';'?
;
NamespaceMember:
	=>Namespace|=>Struct|=>Class|=>Enum|=>Interface|=>Delegate;
Member:
	=>Struct|=>Class|=>Interface|=>Delegate|=>Enum|=>Field|=>Method|=>Constant|=>Property|=>Event|=>Indexer|=>Operator|=>Constructor|=>Destructor|=>StaticConstructor
;
enum MethodModifier:
	new|public|protected|internal|private|static|virtual|sealed|override|abstract|extern|async|unsafe|partial
;
enum ClassModifier:
	new|public|protected|internal|private|abstract|sealed|static|unsafe|partial
;
enum FieldModifier:
	new|public|protected|internal|private|static|readonly|volatile|unsafe;
enum StructModifier:
	new|public|protected|internal|private|unsafe;
enum EnumModifier:
	new|public|protected|internal|private;
Method:
	attributes+=AttributeSection*
 	modifiers+=MethodModifier*
 	type=QUALIFIEDTYPE
 	(memberName=QUALIFIEDTYPE '.')? name=WORD
 	('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
 	'(' 
 	(
 		parameters+=Parameter (',' parameters+=Parameter)*
 	)?
 	')'
 	typeConstraints+=TypeConstraint*
 	(
 		'{' statements+=Statement*	'}' |
 		'=>' expression=Expression ';' |
 		empty?=';'
 	);

Property:
	attributes+=AttributeSection*
	modifiers+=PropertyModifier*
	type=QUALIFIEDTYPE
	(memberName=WORD '.')? // Should be type
	name=WORD
	(
		'{'
			(
				=>getter=Getter =>setter=Setter? |
				=>setter=Setter =>getter=Getter?
			)
		'}'
		('=' expression=Expression ';')?|
		'=>' expression=Expression ';'
	)
;
enum PropertyModifier:
	new|public|internal|protected|private|static|virtual|sealed|override|abstract|extern|unsafe;

Getter: {Getter}
	attributes+=AttributeSection*
	modifier=AccessModifier?
	'get'
	(
	'{' statements+=Statement* '}'|
	empty?=';'
	)
;

Setter: {Setter}
	attributes+=AttributeSection*
	modifier=AccessModifier?
	'set'
	(
	'{' statements+=Statement* '}'|
	empty?=';'
	)
;

enum AccessModifier:
	protected|internal|private
;

Event:
	attributes+=AttributeSection*
	modifiers+=EventModifier*
	'event'
	type=QUALIFIEDTYPE
	(
		declarators+=FieldDeclarator (',' declarators+=FieldDeclarator)*
		';'
		|
		(memberName=WORD '.')?  // Should be type
		name=WORD
		'{' (=>add=Add remove=Remove|remove=Remove add=Add) '}'
	)
;
enum EventModifier:
	new|public|protected|internal|private|static|virtual|sealed|override|abstract|extern|unsafe;

Add: {Add}
	attributes+=AttributeSection*
	'add'
	'{' statements+=Statement* '}'
;

Remove: {Remove}
	attributes+=AttributeSection*
	'remove'
	'{' statements+=Statement* '}'
;

Indexer:
	attributes+=AttributeSection*
	modifiers+=IndexerModifier*
	type=QUALIFIEDTYPE
	(interface=QUALIFIEDTYPE '.')?
	'this'
	'[' parameters+=Parameter (',' parameters+=Parameter)* ']'
	(
		'{' (=>getter=Getter setter=Setter | setter=Setter getter=Getter) '}'
		|
		'=>' expression=Expression ';'
	)
;
enum IndexerModifier:
	new|public|protected|internal|private|virtual|sealed|override|abstract|extern|unsafe;

Operator:
	attributes+=AttributeSection*
	modifiers+=OperatorModifier+
	(
		=>(type=QUALIFIEDTYPE 'operator' unaryOperator=UnaryOperator '(' firstType=QUALIFIEDTYPE firstName=WORD ')')|
		=>(type=QUALIFIEDTYPE 'operator' binaryOperator=BinaryOperator '(' firstType=QUALIFIEDTYPE firstName=WORD ',' secondType=QUALIFIEDTYPE secondName=WORD ')')|
		=>((implicit?='implicit'|explicit?='explicit') 'operator' type=TYPE '(' firstType=QUALIFIEDTYPE firstName=WORD ')') // Should be type
	)
	('{' statements+=Statement* '}'|'=>' expression=Expression ';'|empty?=';')
;
enum UnaryOperator:
	plus='+'|minus='-'|not='!'|bitwiseNot='~'|increment='++'|decrement='--'|t='true'|f='false';
enum BinaryOperator:
	plus='+'|minus='-'|times='*'|divide='/'|remainder='%'|bitwiseAnd='&'|bitwiseOr='|'|bitwiseXor='^'|leftShift='<<'|rightShift='>>'|equal='=='|notEqual='!='|greater='>'|greaterOrEqual='>='|lower='<'|lowerOrEqual='<='
;
enum OperatorModifier:
	public|static|extern|unsafe
;

Constructor:
	attributes+=AttributeSection*
	modifiers+=ConstructorModifier*
	name=WORD
	'(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')'
	(':' (base?='base'|'this') '(' (arguments+=Argument (',' arguments+=Argument)*)? ')')?
	('{' statements+=Statement* '}'|empty?=';')
;
enum ConstructorModifier:
	public|protected|internal|private|extern|unsafe
;
StaticConstructor:
	attributes+=AttributeSection*
	(extern?='extern'? 'static'|'static' extern?='extern')
	name=WORD
	'(' ')'
	('{' statements+=Statement* '}' | empty?=';')
;
Destructor:
	attributes+=AttributeSection*
	extern?='extern'?
	'~'
	name=WORD
	'(' ')'
	('{' statements+=Statement* '}'|empty?=';')
;
Field:
	attributes+=AttributeSection*
	modifiers+=FieldModifier*
	type=QUALIFIEDTYPE
	declarators+=FieldDeclarator (',' declarators+=FieldDeclarator)*
	';'
;
FieldDeclarator:
	name=WORD ('=' value=(Expression|ArrayInitializer))?
;

Constant:
	attributes+=AttributeSection*
	modifiers+=ConstantModifier*
	'const'
	type=QUALIFIEDTYPE
	declarators+=ConstantDeclarator (',' declarators+=ConstantDeclarator)*
	';'
;

ConstantDeclarator:
	name=WORD '=' value=Expression
;

Struct:
	attributes+=AttributeSection*
	modifiers+=StructModifier*
	 'struct' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	(':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

Class:
	attributes+=AttributeSection*
	 modifiers+=ClassModifier*
	 'class' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	(':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

Enum:
	attributes+=AttributeSection*
	modifiers+=EnumModifier*
	 'enum' name=WORD
	 (':' base=WORD)?
	 '{' (values+=WORD (',' values+=WORD)*)? '}'
	 ';'?
;

Interface:
	(attributes+=AttributeSection)*
	 modifiers+=InterfaceModifier*
	 'interface' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	 (':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	 typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

enum InterfaceModifier:
	new|public|protected|internal|private|partial|unsafe
;

Delegate:
	attributes+=AttributeSection*
	modifiers+=DelegateModifiers*
	'delegate' returnType=QUALIFIEDTYPE
	name=WORD
	('<' variants+=VariantParameter (',' variants+=VariantParameter)* '>')?
	'(' (parameters+=Parameter (','parameters+=Parameter)*)? ')'
 	typeConstraints+=TypeConstraint*
	';'
;
VariantParameter:
	attributes+=AttributeSection*
	varianceAttributeSection=VarianceAttributeSection?
	type=WORD
;
enum VarianceAttributeSection:
	none|in|out
;
enum DelegateModifiers:
	new|public|protected|internal|private|unsafe;
enum ConstantModifier:
	new|public|private|protected|internal
;


Parameter:
	attributes+=AttributeSection*
	(ref?='ref'|out?='out'|this?='this')?
	params?='params'?
	type=QUALIFIEDTYPE
	name=WORD
	('=' default=Expression)?;

AttributeSection:
	'[' (target=AttributeTarget ':')? attributes+=Attribute (',' attributes+=Attribute)* ']';

enum AttributeTarget:
	field|event|method|param|property|return|type
;
@Override
Statement:
	Foreach|For|Iteration|Selection|=>Declaration|Call|Return|EmptyStatement|Try
;

EmptyStatement:{EmptyStatement}';';

Try:
	'try'
	'{' statements+=Statement* '}'
	catches+=Catch+
	(
	'finally'
	'{' finally+=Statement*	'}'
	)?
;

Catch: {Catch}
	'catch'
	('(' type=QUALIFIEDTYPE variable=WORD? ')')?
	('when' '(' filter=Expression ')')?
	'{' statements+=Statement* '}'
;

@Override
Iteration:
	'while' '(' condition=Expression ')'
	'{' statements+=Statement* '}';

@Override
Selection:
	'if' branches+=Branch
	('else' 'if' branches+=Branch)*
	('else' branches+=Block)?;

For:
	'for' '(' initialization=Expression ';' condition=Expression ';' increment=Expression ')'
	'{'
	statements+=Statement*
	'}';

Foreach:
	'foreach' '(' ('var'|type=QUALIFIEDTYPE) variable=WORD 'in' collection=Expression ')'
	'{' statements+=Statement* '}'
;
Return:
	'return' expression=Expression ';';

Lambda: {Lambda}
	'(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '=>' '{' statements+=Statement* '}';

ArrayInitializer: {ArrayInitializer}
	'{' 
	(variables+=(Expression|ArrayInitializer) (',' variables+=(Expression|ArrayInitializer))* 
	','? )? '}'
;

@Override
Atomic returns Expression: 
	FloatLiteral |
	StringLiteral |
	BooleanLiteral |
	(=>Function|
	Variable)|
	Index
;

@Override
Function returns Function: {ParameterizedFunction}
	name=WORD
	('<' types+=QUALIFIEDTYPE (',' types+=QUALIFIEDTYPE)* '>')?
	'(' (arguments+=Argument (',' arguments+=Argument)*)? ')'
;

Argument:
	(name=WORD':')?
	(
		value=Expression
		|ref?='ref' value=Variable
		|out?='out' value=Variable
	)
;

Index:
	name=WORD
	'[' indices+=Expression (',' indices+=Expression)? ']'
;

Declaration:
	('var'|type=QUALIFIEDTYPE) variable=WORD (';'|kind=AssignmentKind new?='new'? expression=Expression ';');

Call:
	call=AccessExpression ';'
;

QUALIFIEDNAME: WORD ('.' WORD)*;
TypeParameter: 
	attributes+=AttributeSection* 
	name=WORD
;
TYPE:
	WORD ('<' TYPE (',' TYPE)* '>')? ('[' ','* ']')?
;
TypeConstraint:
	'where' type=WORD
	':' 
	(
		(class?='class'|struct?='struct') (',' constructor?='new' '(' ')')? |
		(class?='class'|struct?='struct') (',' superTypes+=QUALIFIEDTYPE)+ (',' constructor?='new' '(' ')')? |
		superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)* (',' constructor?='new' '(' ')')? |
		constructor?='new' '(' ')'		
	)
;
FloatLiteral returns Expression: {FloatLiteral}	value=NUMBER;
StringLiteral returns Expression: {StringLiteral} value=STRING;
BooleanLiteral returns Expression: {BooleanLiteral}	value=BOOLEAN;
terminal BOOLEAN: '⊤'|'⊥';
terminal STRING: '"' -> '"';

terminal MULTIPLE_LINES_COMMENT: '/*'->'*/ ';
terminal SINGLE_LINE_COMMENT: '//' !('\n' | '\r')* ('\r'? '\n')?;