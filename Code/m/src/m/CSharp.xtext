grammar m.CSharp with m.Modular hidden(WS, MULTIPLE_LINES_COMMENT, SINGLE_LINE_COMMENT)

import "azpillaga.world/modular"
generate csharp "azpillaga.world/csharp"

// => ( grammar ) significa
// Si y solo si todo de grammar esta presente, sigue por este camino
// Sino busca una alternativa
// Si y solo si!
// Si esta presente sigue por aqui pero solo si esta presente
// Ejemplo
// Si hago en Mem: =>(modifiers+=Modifier*) ...
// Si esta presente y solo si esta presente ire por este camino
// Pero esto es siempre dado que 0 modifiers siempre estaran presentes
// Ahora, si hago en Mem: =>(modifiers* type name typeparams* '(' )
// Si hayu un parentesis a la vista cogere este camino pero solo si hay un
// parentesis a la vista.
//
// El orden y los parentesis importan mucho. Ejemplo =>Field|Method no
// funciona, ni (Method|=>Field) pero (=>Field|Method) si
// Siempre poner => en la primera alternativa, reordenar para optimizar si eso

CompilationUnit:
	externAliases+=ExternAlias*
	globalAttributes+=GlobalAttribute*
	usings+=Using*
	types+=NamespaceMember*;

GlobalAttribute:
	'[' ('assembly'|'module') ':' attributes+=Attribute (',' attributes+=Attribute)* ']';

Attribute:
	name=WORD arguments=AttributeArguments?
;
AttributeArguments: {AttributeArguments}
	'(' 
	(
		positionals+=LogicalOr (',' positionals+=LogicalOr)*
		(',' named+=NamedArgument (',' named+=NamedArgument)*)?
		|
		named+=NamedArgument (',' named+=NamedArgument)*
	)?
	')'
;
NamedArgument:
	name=WORD '=' expression=Expression
;
ExternAlias:
	'extern' 'alias' name=WORD ';'
;
Using:
	AliasUsing|NamespaceUsing|StaticUsing;

AliasUsing:
	'using'
	alias=WORD '=' namespace=QUALIFIEDTYPE
	';'
;
QUALIFIEDTYPE:
	TYPE ('.' TYPE)*
	|
	WORD '::' TYPE ('.' TYPE)*
;
NamespaceUsing:
	'using'
	namespace=QUALIFIEDTYPE
	';'
;
StaticUsing:
	'using'
	'static'
	namespace=QUALIFIEDTYPE
	';'
;

Namespace:
	'namespace' qname=QUALIFIEDNAME 
	'{' 
	externAliases+=ExternAlias*
	usings+=Using*
	members+=NamespaceMember* 
	'}'
	 ';'?
;
NamespaceMember:
	=>Namespace|=>Struct|=>Class|=>Enum|=>Interface|=>Delegate;
Member:
	=>Struct|=>Class|=>Interface|=>Delegate|=>Enum|=>Field|=>Method|=>Constant|=>Property|=>Event|=>Indexer|=>Operator|=>Constructor|=>Destructor|=>StaticConstructor
;
enum MethodModifier:
	new|public|protected|internal|private|static|virtual|sealed|override|abstract|extern|async|unsafe|partial
;
enum ClassModifier:
	new|public|protected|internal|private|abstract|sealed|static|unsafe|partial
;
enum FieldModifier:
	new|public|protected|internal|private|static|readonly|volatile|unsafe;
enum StructModifier:
	new|public|protected|internal|private|unsafe;
enum EnumModifier:
	new|public|protected|internal|private;
Method:
	attributes+=AttributeSection*
 	modifiers+=MethodModifier*
 	type=QUALIFIEDTYPE
 	(memberName=QUALIFIEDTYPE '.')? name=WORD
 	('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
 	'(' 
 	(
 		parameters+=Parameter (',' parameters+=Parameter)*
 	)?
 	')'
 	typeConstraints+=TypeConstraint*
 	(
 		'{' statements+=Statement*	'}' |
 		'=>' expression=Expression ';' |
 		empty?=';'
 	);

Property:
	attributes+=AttributeSection*
	modifiers+=PropertyModifier*
	type=QUALIFIEDTYPE
	(memberName=WORD '.')? // Should be type
	name=WORD
	(
		'{'
			(
				=>getter=Getter =>setter=Setter? |
				=>setter=Setter =>getter=Getter?
			)
		'}'
		('=' expression=Expression ';')?|
		'=>' expression=Expression ';'
	)
;
enum PropertyModifier:
	new|public|internal|protected|private|static|virtual|sealed|override|abstract|extern|unsafe;

Getter: {Getter}
	attributes+=AttributeSection*
	modifier=AccessModifier?
	'get'
	(
	'{' statements+=Statement* '}'|
	empty?=';'
	)
;

Setter: {Setter}
	attributes+=AttributeSection*
	modifier=AccessModifier?
	'set'
	(
	'{' statements+=Statement* '}'|
	empty?=';'
	)
;

enum AccessModifier:
	protected|internal|private
;

Event:
	attributes+=AttributeSection*
	modifiers+=EventModifier*
	'event'
	type=QUALIFIEDTYPE
	(
		declarators+=FieldDeclarator (',' declarators+=FieldDeclarator)*
		';'
		|
		(memberName=WORD '.')?  // Should be type
		name=WORD
		'{' (=>add=Add remove=Remove|remove=Remove add=Add) '}'
	)
;
enum EventModifier:
	new|public|protected|internal|private|static|virtual|sealed|override|abstract|extern|unsafe;

Add: {Add}
	attributes+=AttributeSection*
	'add'
	'{' statements+=Statement* '}'
;

Remove: {Remove}
	attributes+=AttributeSection*
	'remove'
	'{' statements+=Statement* '}'
;

Indexer:
	attributes+=AttributeSection*
	modifiers+=IndexerModifier*
	type=QUALIFIEDTYPE
	(interface=QUALIFIEDTYPE '.')?
	'this'
	'[' parameters+=Parameter (',' parameters+=Parameter)* ']'
	(
		'{' (=>getter=Getter setter=Setter | setter=Setter getter=Getter) '}'
		|
		'=>' expression=Expression ';'
	)
;
enum IndexerModifier:
	new|public|protected|internal|private|virtual|sealed|override|abstract|extern|unsafe;

Operator:
	attributes+=AttributeSection*
	modifiers+=OperatorModifier+
	(
		=>(type=QUALIFIEDTYPE 'operator' unaryOperator=UnaryOperator '(' firstType=QUALIFIEDTYPE firstName=WORD ')')|
		=>(type=QUALIFIEDTYPE 'operator' binaryOperator=BinaryOperator '(' firstType=QUALIFIEDTYPE firstName=WORD ',' secondType=QUALIFIEDTYPE secondName=WORD ')')|
		=>((implicit?='implicit'|explicit?='explicit') 'operator' type=TYPE '(' firstType=QUALIFIEDTYPE firstName=WORD ')') // Should be type
	)
	('{' statements+=Statement* '}'|'=>' expression=Expression ';'|empty?=';')
;
enum UnaryOperator:
	plus='+'|minus='-'|not='!'|bitwiseNot='~'|increment='++'|decrement='--'|t='true'|f='false';
enum BinaryOperator:
	plus='+'|minus='-'|times='*'|divide='/'|remainder='%'|bitwiseAnd='&'|bitwiseOr='|'|bitwiseXor='^'|leftShift='<<'|rightShift='>>'|equal='=='|notEqual='!='|greater='>'|greaterOrEqual='>='|lower='<'|lowerOrEqual='<='
;
enum OperatorModifier:
	public|static|extern|unsafe
;

Constructor:
	attributes+=AttributeSection*
	modifiers+=ConstructorModifier*
	name=WORD
	'(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')'
	(':' (base?='base'|'this') '(' (arguments+=Argument (',' arguments+=Argument)*)? ')')?
	('{' statements+=Statement* '}'|empty?=';')
;
enum ConstructorModifier:
	public|protected|internal|private|extern|unsafe
;
StaticConstructor:
	attributes+=AttributeSection*
	(extern?='extern'? 'static'|'static' extern?='extern')
	name=WORD
	'(' ')'
	('{' statements+=Statement* '}' | empty?=';')
;
Destructor:
	attributes+=AttributeSection*
	extern?='extern'?
	'~'
	name=WORD
	'(' ')'
	('{' statements+=Statement* '}'|empty?=';')
;
Field:
	attributes+=AttributeSection*
	modifiers+=FieldModifier*
	type=QUALIFIEDTYPE
	declarators+=FieldDeclarator (',' declarators+=FieldDeclarator)*
	';'
;
FieldDeclarator:
	name=WORD ('=' value=(Expression|ArrayInitializer))?
;

Constant:
	attributes+=AttributeSection*
	modifiers+=ConstantModifier*
	'const'
	type=QUALIFIEDTYPE
	declarators+=ConstantDeclarator (',' declarators+=ConstantDeclarator)*
	';'
;

ConstantDeclarator:
	name=WORD '=' value=Expression
;

Struct:
	attributes+=AttributeSection*
	modifiers+=StructModifier*
	 'struct' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	(':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

Class:
	attributes+=AttributeSection*
	 modifiers+=ClassModifier*
	 'class' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	(':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

Enum:
	attributes+=AttributeSection*
	modifiers+=EnumModifier*
	 'enum' name=WORD
	 (':' base=WORD)?
	 '{' (values+=WORD (',' values+=WORD)*)? '}'
	 ';'?
;

Interface:
	(attributes+=AttributeSection)*
	 modifiers+=InterfaceModifier*
	 'interface' name=WORD
	 ('<' typeParameters+=TypeParameter (',' typeParameters+=TypeParameter)* '>')?
	 (':' superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)*)?
	 typeConstraints+=TypeConstraint*
	 '{' members+=Member* '}'
	 ';'?
;

enum InterfaceModifier:
	new|public|protected|internal|private|partial|unsafe
;

Delegate:
	attributes+=AttributeSection*
	modifiers+=DelegateModifiers*
	'delegate' returnType=QUALIFIEDTYPE
	name=WORD
	('<' variants+=VariantParameter (',' variants+=VariantParameter)* '>')?
	'(' (parameters+=Parameter (','parameters+=Parameter)*)? ')'
 	typeConstraints+=TypeConstraint*
	';'
;
VariantParameter:
	attributes+=AttributeSection*
	varianceAttributeSection=VarianceAttributeSection?
	type=WORD
;
enum VarianceAttributeSection:
	none|in|out
;
enum DelegateModifiers:
	new|public|protected|internal|private|unsafe;
enum ConstantModifier:
	new|public|private|protected|internal
;


Parameter:
	attributes+=AttributeSection*
	(ref?='ref'|out?='out'|this?='this')?
	params?='params'?
	type=QUALIFIEDTYPE
	name=WORD
	('=' default=Expression)?;

AttributeSection:
	'[' (target=AttributeTarget ':')? attributes+=Attribute (',' attributes+=Attribute)* ']';

enum AttributeTarget:
	field|event|method|param|property|return|type
;
@Override
Statement:
	LabeledStatement|Foreach|For|Do|Iteration|Selection|Switch|=>Declaration|ExpressionStatement|Return|Yield|Break|Continue|Goto|EmptyStatement|Try
	|Lock|Checked|Unchecked|Throw
;

LabeledStatement:
	=>(label=WORD ':') statement=Statement
;

EmptyStatement:{EmptyStatement}';';

Try:
	'try'
	'{' statements+=Statement* '}'
	catches+=Catch+
	(
	'finally'
	'{' finally+=Statement*	'}'
	)?
;

Catch: {Catch}
	'catch'
	('(' type=QUALIFIEDTYPE variable=WORD? ')')?
	('when' '(' filter=Expression ')')?
	'{' statements+=Statement* '}'
;

@Override
Iteration:
	'while' '(' condition=Expression ')'
	('{' statements+=Statement* '}'|statements+=Statement);

@Override
Selection:
	'if' branches+=Branch
	('else' 'if' branches+=Branch)*
	('else' branches+=Block)?;

Switch:
	'switch' '(' expression=Expression ')'
	'{' cases+=Case* '}'
;
Case: 
	'case' condition=Expression ':'  statements+=Statement*|
	{Case} 'default' ':' statements+=Statement*
;
For: {For}
	'for' '(' initialization=Statement condition=Expression? ';' iterator=Expression? ')'
	('{' statements+=Statement* '}'|statements+=Statement);

Foreach:
	'foreach' '(' ('var'|type=QUALIFIEDTYPE) variable=WORD 'in' collection=Expression ')'
	('{' statements+=Statement* '}'|statements+=Statement);

Do:
	'do'
	'{' statements+=Statement* '}'
	'while' '(' condition=Expression ')' ';'
;

Return:
	'return' expression=Expression ';';
Yield:
	'yield' (break?='break'|'return' expression=Expression) ';'
;
Break: {Break}
	'break'';'
;
Continue: {Continue}
	'continue' ';'
;
Goto:
	'goto' label=WORD|
	'goto' 'case' case=Expression ';'|
	'goto' default?='default' ';'
;
Throw:
	'throw' expression=Expression ';';

Checked: {Checked}
	'checked'
	('{' statements+=Statement* '}'|statements+=Statement);

Unchecked: {Unchecked}
	'unchecked'
	('{' statements+=Statement* '}'|statements+=Statement);

Lock:
	'lock' '(' expression=Expression ')'
	('{' statements+=Statement* '}'|statements+=Statement);

Lambda returns Expression: {Lambda}
	'(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '=>' '{' statements+=Statement* '}';

ArrayInitializer: {ArrayInitializer}
	'{' 
	(variables+=(Expression|ArrayInitializer) (',' variables+=(Expression|ArrayInitializer))* 
	','? )? '}'
;

@Override
Atomic returns Expression:
	(FloatLiteral |
	StringLiteral |
	BooleanLiteral |
	(=>ParameterizedFunction|
	Variable)|
	Creation|
	Index|
	This|
	Base|
	Default|
	Typeof)
;

This returns Expression: {This} 'this';
Base returns Expression: {Base} 'base';
Default returns Expression: {Default} 'default';
Typeof returns Expression: {Typeof}
	(
	'typeof' '(' type=WORD ')'|
	'typeof' '(' unboundType=QUALIFIEDTYPE '<' dimensions+=','* '>' ')'
	);

Creation returns Expression: {Creation}
	'new' type=WORD // Should be qualifiedType
	((
		(
			=>('{' (members+=MemberInitializer (',' members+=MemberInitializer)*)? '}')
			|
			=>('{' elements+=LogicalOr (',' elements+=LogicalOr)* '}')
		)
	)|(
		'(' (arguments+=Argument (',' arguments+=Argument)*)? ')'
		(
			=>('{' (members+=MemberInitializer (',' members+=MemberInitializer)*)? '}')
			|
			=>('{' elements+=LogicalOr (',' elements+=LogicalOr)* '}')
		)?
	))
;

MemberInitializer:
	name=WORD '=' value=Expression|
	'[' indices+=Expression (',' indices+=Expression)* ']' '=' value=Expression
;

ParameterizedFunction:
	name=WORD
	('<' types+=QUALIFIEDTYPE (',' types+=QUALIFIEDTYPE)* '>')?
	'(' (arguments+=Argument (',' arguments+=Argument)*)? ')'
;

Argument:
	(name=WORD':')?
	(
		value=Expression
		|ref?='ref' value=Variable
		|out?='out' value=Variable
	)
;

Index:
	name=WORD
	'[' indices+=Expression (',' indices+=Expression)? ']'
;

Declaration:
	('var'|constant?='const'? type=QUALIFIEDTYPE) declarators+=Declarator+ ';';

Declarator:
	variable=WORD ('=' value=(Expression|ArrayInitializer))?
;
ExpressionStatement:
	expression=Expression ';'
;

@Override
Expression:
	=>Lambda|Assignment
;

@Override
Assignment returns Expression:
	Ternary ({Assignment.left=current} kind=AssignmentKind right=Ternary)*;

Ternary returns Expression:
	NullCoalescing ({Ternary.left=current} '?' yes=NullCoalescing ':' no=NullCoalescing)*;

NullCoalescing returns Expression:
	LogicalOr ({NullCoalescing.left=current} '??' right=LogicalOr)*;

@Override
AccessExpression returns Expression:
	Postfix ({AccessExpression.left=current} '.' right=Postfix)*;

Postfix returns Expression:
	Atomic (({Increment.expression=current} '++')|({Decrement.expression=current} '--'))?
;
QUALIFIEDNAME: WORD ('.' WORD)*;
TypeParameter: 
	attributes+=AttributeSection* 
	name=WORD
;
TYPE:
	WORD ('<' TYPE (',' TYPE)* '>')? ('[' ','* ']')?
;
TypeConstraint:
	'where' type=WORD
	':' 
	(
		(class?='class'|struct?='struct') (',' constructor?='new' '(' ')')? |
		(class?='class'|struct?='struct') (',' superTypes+=QUALIFIEDTYPE)+ (',' constructor?='new' '(' ')')? |
		superTypes+=QUALIFIEDTYPE (',' superTypes+=QUALIFIEDTYPE)* (',' constructor?='new' '(' ')')? |
		constructor?='new' '(' ')'		
	)
;
FloatLiteral returns Expression: {FloatLiteral}	value=NUMBER;
StringLiteral returns Expression: {StringLiteral} value=STRING;
BooleanLiteral returns Expression: {BooleanLiteral}	value=BOOLEAN;
terminal BOOLEAN: '⊤'|'⊥';
terminal STRING: '"' -> '"';

terminal MULTIPLE_LINES_COMMENT: '/*'->'*/ ';
terminal SINGLE_LINE_COMMENT: '//' !('\n' | '\r')* ('\r'? '\n')?;