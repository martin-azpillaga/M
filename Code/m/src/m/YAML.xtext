grammar m.YAML hidden()

import "http://www.eclipse.org/emf/2002/Ecore" 
generate yaml "azpillaga.world/yaml"

// WS? before terminals, but not before ParserRules!
// Force a WS where needed
// : included in NOSPACE as otherwise they are keywords
// terminal rule SPACE and force a space after :
Stream:
	(directives+=Directive|documents+=Document)*;

Directive: Version|Tag;
Version:
	WS? '%YAML' 
	WS? version=DATA 
	WS;
Tag:
	WS? '%TAG'
	WS? '!'name=DATA'!'
	WS? value=DATA 
	WS;

Document:
	(WS? '---')?
	root=Node
	(WS? '...' )?
	 WS;
TagRef:
	LocalTag|GlobalTag|ResolvedTag
;
LocalTag:
	WS? '!' handle=DATA'!' WS? data=DATA WS;
GlobalTag:
	WS? '!!' handle=DATA WS
;
ResolvedTag:
	WS? '!<' handle=DATA'>'
;
Node:
	RegularNode|AliasNode
;
RegularNode:
	tag=TagRef?
	(WS? '&' WS? name=DATA WS)?
	root=Value
;
AliasNode:
	WS? '*' alias=[RegularNode|DATA]
;
Value:
	DataValue|SingleValue|DoubleValue|Sequence|Map|M
;
DoubleValue: WS? value=STRING;
SingleValue: WS? value=SINGLE_STRING;
DataValue: WS? value=DATA;
Sequence:{Sequence} 
	WS? '['
	 (elements+=Value
	(WS? ', '
	 elements+=Value)*)?
	WS? ']';
Map:{Map}
	WS? '{'
	 (pairs+=Pair
	(WS? ', ' pairs+=Pair)*)?
	WS? '}';
Pair:
	WS? key=(DATA|STRING|SINGLE_STRING) WS? ': ' value=Value
;
M:
	key=DATA ': ' WS BEGIN body+=Value (WS body+=Value)* WS? END;
/*
Node:
	ValueNode|AliasNode
;
ValueNode:
	((tag=TagRef VERTICAL? ('&' name=DATA)? VERTICAL)|
	('&' name=DATA VERTICAL? tag=TagRef? VERTICAL))?
	value=Value
;

AliasNode:
	'*'alias=[ValueNode|DATA]
;
TagRef:
	LocalTag|GlobalTag|ResolvedTag;

LocalTag:
	'!' handle=DATA '!' value=DATA;
GlobalTag:
	'!!' handle=DATA;
ResolvedTag:
	'!<' handle=DATA '>';
@Override
Value:
	Object|Array|StringValue|SingleValue|DataValue
;
SingleValue:
	value=SINGLE_STRING
;
DataValue:
	value=DATA
;
@Override 
Member:
	name = (STRING|DATA|SINGLE_STRING) (HORIZONTAL|VERTICAL)*
	':' (HORIZONTAL|VERTICAL)* value=Value;*/
/*
@Override
Value:
	Scalar|Sequence;//|Mapping;

Scalar:
	PlainScalar|SingleScalar|DoubleScalar;
PlainScalar:
	value=DATA;
SingleScalar:
	value=SINGLE_STRING;
DoubleScalar:
	value=STRING;

Sequence:
	SequenceBlock;//|SequenceFlow;
Mapping:
	MappingFlow;

SequenceBlock: {SequenceBlock}
	('-' SPACE elements+=Value WS)*
;
SequenceFlow: {SequenceFlow}
	'[' (SPACE|WS)* (elements+=Value (SPACE|WS)*(',' (SPACE|WS)* elements+=Value(SPACE|WS)*)*)? ']';

MappingFlow: {MappingFlow}
	'{' (SPACE|WS)*(pairs+=Pair (SPACE|WS)*(',' (SPACE|WS)* pairs+=Pair(SPACE|WS)*)*)? '}';

Pair:
	key=DATA (SPACE|WS)*':' (SPACE|WS)*value=Value;

KeyValue:
	key=DATA ':' SPACE value=Element?;

Map:
	key=DATA ':' WS BEGIN body+=Value (WS body+=Value)* WS? END;

KeyValueList:
	name=DATA ':' WS '-' SPACE values+=(KeyValue | Element) (WS '-' SPACE values+=(KeyValue | Element))*;

Element:
	InlineMap | InlineList | InlineSemicolonList | {Word} value=DATA | {Float} value=NUMBER;

InlineList:
	{InlineList} '[' (elements+=Element (',' SPACE elements+=Element)*)? ']';

InlineMap:
	{InlineMap} '{' (SPACE? values+=KeyValue (',' SPACE values+=KeyValue)* SPACE?)? '}';

InlineSemicolonList:
	{InlineSemicolonList} elements+=DATA ';' elements+=DATA (';' elements+=DATA)*;
*/
DATA: (NOSPACE)+;

//terminal COMMENT: ' #' (NOSPACE|' '|'\t')* NOSPACE;
terminal STRING: '"' -> '"';
terminal SINGLE_STRING: '\'' -> '\'';
terminal NOSPACE: '\u0021'..'\u007e'|'\u00a0'..'\uffff';
terminal WS: (' '|'\t'|'\n'|'\r')+;

terminal BEGIN:	'synthetic:BEGIN';
terminal END: 'synthetic:END';