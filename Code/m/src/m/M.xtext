grammar m.M with m.Modular
import "azpillaga.world/modular"
generate m "azpillaga.world/m"

// The definable set are those definable by expressions!

Game:
	(archetypes+=Archetype|systems+=System)*
	end=End;

Archetype:
	 name = WORD '≔'
	(base=WORD '∪')?
	 '{' components+=WORD (','? components+=WORD)* '}';

System:
	name=WORD '≔' 
	'['	statements+=Statement+ ']';

@Override
Statement:
	Selection|Iteration|Forall|Assignment|Function;

@Override
Selection: {MySelection}
	'→' condition=Expression  '[' yes+=Statement* ']'
	('[' no+=Statement* ']')?;

@Override
Iteration returns Block: {Iteration}
	'↺' condition=Expression
	'[' statements+=Statement* ']';

Forall returns Block: {Forall}
	 '∀' variable=WORD
	 '[' statements+=Statement* ']';

Assignment:
	variable=(Variable|ComponentAccess) '≔' expression=Expression;

@Override
Function returns Expression: {Function}
	name=WORD
	'[' (arguments+=Expression (','? arguments+=Expression)*)? ']';

@Override
Expression:LogicalOr;

@Override
LogicalOr returns Expression:
  LogicalAnd ({LogicalOr.left=current}  '⋁' right=LogicalAnd)*;
  
@Override
LogicalAnd returns Expression:
  Equality ({LogicalAnd.left=current}  '⋀' right=Equality)*;

@Override
Equality returns Expression:
	Comparison ({Equality.left=current}  kind=EqualityKind right=Comparison)*;

@Override
Comparison returns Expression:
	AdditiveExpression (({Comparison.left=current}  kind=ComparisonKind right=AdditiveExpression))*;

@Override
AdditiveExpression returns Expression:
	MultiplicativeExpression ({AdditiveExpression.left=current}  kind=AdditiveKind right=MultiplicativeExpression)*;

@Override
MultiplicativeExpression returns Expression:
	SetExpression ({MultiplicativeExpression.left=current}  kind=MultiplicativeKind right=SetExpression)*;

SetExpression returns Expression:
	ConcatenateExpression ({SetExpression.left=current} kind=SetKind right=ConcatenateExpression)*;

ConcatenateExpression returns Expression:
	Primary ({ConcatenateExpression.left=current} '~' right=Primary)*;

@Override
Primary returns Expression:
	=>ComponentAccess|=>Function|Variable|=>ImplicitSet|ExplicitSet|LogicalNot|Brackets|Cardinal|Join;

@Override
Brackets returns Expression: {Brackets}
	'(' expression=Expression ')';

@Override
LogicalNot returns Expression: {LogicalNot} 
	'¬' expression=Primary;

Cardinal returns Expression: {Cardinal}
	'#' expression=Primary;

Join returns Expression: {Join}
	=>('[' entries+=Expression (','? entries+=Expression)+ ']');

@Override
Variable returns Expression: {Variable}
	name=WORD;

ComponentAccess returns Expression: {ComponentAccess}
	entity=WORD '.' component=WORD;

ImplicitSet returns Expression: {ImplicitSet}
	'{' variable=WORD '|' predicate=Expression '}';

ExplicitSet returns Expression: {ExplicitSet}
	'{' elements+=Expression (','? elements+=Expression)* '}';

End: {End};

@Override
terminal WORD: (START_ID|'_') CONTINUE_ID*;
@Override
terminal WS: (' '|'\n'|'\r'|'\t')+;

@Override
enum ComparisonKind: lower='<'|lowerOrEqual='≤'|greaterOrEqual='≥'|greater='>';
@Override
enum AdditiveKind: add='+'|subtract='-';
enum SetKind: membership='∈'|union='∪'|intersection='∩'|difference='∖';
@Override
enum EqualityKind: equal='='|notEqual='≠';
@Override
enum MultiplicativeKind: multiply='×'|divide='÷';