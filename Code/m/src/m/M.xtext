grammar m.M with m.Modular
import "azpillaga.world/modular"
generate m "azpillaga.world/m"

// The definable set are those definable by expressions!

Game:
	(archetypes+=Archetype|systems+=System)*
	end=End;

Archetype:
	 name = WORD '≔'
	(base=WORD '∪')?
	 '{' components+=Component (','? components+=Component)* '}';

Component:
	name=WORD|
	{VectorComponent} name=WORD '[' entries+=NUMBER (','? entries+=NUMBER)* ']';

System:
	name=WORD '≔'
	statements+=Statement+;

@Override
Statement:
	Selection|Iteration|Forall|Exists|Assignment|Function;

Forall returns Block: {Forall}
	 '∀' variable=WORD
	('|' condition=Expression)?
	 '[' statements+=Statement (','? statements+=Statement)* ']';

Exists returns Block: {Exists}
	(negated?='∄'|'∃')
	 variable=WORD
	('|' condition=Expression)?
	 '[' statements+=Statement (','? statements+=Statement)* ']';

@Override
Branch returns Block: {Branch}
	condition=Expression
	'[' statements+=Statement (','? statements+=Statement)* ']';

@Override
Block returns Block: {Block}
	'[' statements+=Statement (','? statements+=Statement)* ']';

@Override
Iteration returns Block: {Iteration}
	'↺' condition=Expression
	'[' statements+=Statement (','? statements+=Statement)* ']';

@Override
LogicalNot returns Expression: {LogicalNot} 
	'¬' expression=Primary;

@Override
Equality returns Expression:
	Comparison ({Equality.left=current}  kind=EqualityKind right=Comparison)*;

@Override
MultiplicativeExpression returns Expression:
	SetExpression ({MultiplicativeExpression.left=current} kind=MultiplicativeKind right=SetExpression)*;

SetExpression returns Expression:
	Primary ({SetExpression.left=current} kind=SetKind right=Primary)*;

Assignment:
	variable=(Variable|ComponentAccess) '=' expression=Expression
;

ComponentAccess returns Expression: {ComponentAccess}
	entity=WORD '.' component=WORD;

@Override
Primary returns Expression:
	=>ComponentAccess|=>Function|Variable|=>ImplicitSet|ExplicitSet|LogicalNot|Brackets;

@Override
Function returns Expression: {Function}
	name=WORD
	'[' (arguments+=Expression (','? arguments+=Expression)*)? ']'
;

ImplicitSet returns Expression: {ImplicitSet}
	'{' variable=WORD '|' predicate=Expression '}'
;

ExplicitSet returns Expression: {ExplicitSet}
	'{' elements+=Expression (',' elements+=Expression)* '}';

End: {End};

enum SetKind: membership='∈'|union='∪'|intersection='∩'|difference='∖';
@Override
enum EqualityKind: equal='='|notEqual='≠';
@Override
enum MultiplicativeKind: multiply='×'|divide='÷';
enum AmountKind: lower='<'|lowerOrEqual='≤'|equal='='|notEqual='≠'|greaterOrEqual='≥'|greater='>';