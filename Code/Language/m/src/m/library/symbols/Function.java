package m.library.symbols;

import static m.library.types.AtomicType.*;
import static m.library.types.TypeVariable.A;

import m.library.types.AtomicType;
import m.library.types.FunctionType;
import m.library.types.Type;

public enum Function implements Symbol{
	ABS(NUMBER, NUMBER),
	SIGN(NUMBER, NUMBER),
	CEIL(NUMBER, NUMBER),
	FLOOR(NUMBER, NUMBER),
	ROUND(NUMBER, NUMBER),
	INTEGERPART(NUMBER, NUMBER),
	FRACTIONALPART(NUMBER, NUMBER),
	INVERSE(NUMBER, NUMBER),
	RECIPROCAL(NUMBER, NUMBER),
	
	MAX(NUMBER, NUMBER, NUMBER),
	MIN(NUMBER, NUMBER, NUMBER),
	DEGREES(NUMBER, NUMBER),
	RADIANS(NUMBER, NUMBER),
	SLERP(QUATERNION, QUATERNION, QUATERNION, NUMBER),
	STEP(NUMBER, NUMBER, NUMBER),

	CLAMP(NUMBER, NUMBER, NUMBER2),
	LERP(NUMBER, NUMBER, NUMBER2),
	UNLERP(NUMBER, NUMBER, NUMBER2),
	PROPORTIONAL(NUMBER, NUMBER, NUMBER2, NUMBER2),
	
	SIN(NUMBER, NUMBER),
	COS(NUMBER, NUMBER),
	TAN(NUMBER, NUMBER),
	ASIN(NUMBER, NUMBER),
	ACOS(NUMBER, NUMBER),
	ATAN(NUMBER, NUMBER),
	EXP(NUMBER, NUMBER),
	LOG(NUMBER, NUMBER),
	POW(NUMBER, NUMBER, NUMBER),
	SQRT(NUMBER, NUMBER),
	
	RANDOM(NUMBER, NUMBER2),
	
	CROSS(NUMBER3, NUMBER3, NUMBER3),
	DOT(NUMBER, NUMBER3, NUMBER3),
	NORM(NUMBER, NUMBER3),
	NORMALIZE(NUMBER3, NUMBER3),
	DISTANCE(NUMBER, NUMBER3, NUMBER3),
	REFLECT(NUMBER3, NUMBER3, NUMBER3),
	REFRACT(NUMBER3, NUMBER3, NUMBER3, NUMBER),
	
	OR(PROPOSITION, PROPOSITION, PROPOSITION),
	AND(PROPOSITION, PROPOSITION, PROPOSITION),
	NOT(PROPOSITION, PROPOSITION),
	
	ADDITION(A, A, A),
	SUBTRACTION(A, A, A),
	MULTIPLICATION(A, A, NUMBER),
	DIVISION(A, A, NUMBER),
	
	EQUAL(PROPOSITION, A, A),
	INEQUAL(PROPOSITION, A,A),
	
	LOWER(PROPOSITION, NUMBER, NUMBER),
	LOWEROREQUAL(PROPOSITION, NUMBER, NUMBER),
	GREATEROREQUAL(PROPOSITION, NUMBER, NUMBER),
	GREATER(PROPOSITION, NUMBER, NUMBER),
	
	SIZE(NUMBER, ENTITY_LIST),
	IN(PROPOSITION, ENTITY, ENTITY_LIST),
	XYZ(NUMBER3, NUMBER, NUMBER, NUMBER),
	
	CREATE(ENTITY, ENTITY),
	DESTROY(UNIT, ENTITY),
	ADD(UNIT, COMPONENT, ENTITY),
	REMOVE(UNIT, COMPONENT, ENTITY),
	HAS(PROPOSITION, COMPONENT, ENTITY),
	
	WRITE(UNIT, A),
	WRITEERROR(UNIT, A),
	WRITE_WARNING(UNIT, A),
	HALT(UNIT),
	BREAKPOINT(UNIT),
	SCREENSHOT(UNIT),
	
	OVERLAPS(ENTITY_LIST, ENTITY),
	OVERLAP_COLLIDER(ENTITY_LIST, COLLIDER),
	
	
	SET_NUMBER(UNIT, AtomicType.MATERIAL, STRING, NUMBER),
	SET_COLOR(UNIT, AtomicType.MATERIAL, STRING, COLOR),
	SET_KEYWORD(UNIT, AtomicType.MATERIAL, STRING, PROPOSITION),
	SET_INTEGER(UNIT, AtomicType.MATERIAL, STRING, NUMBER),
	SET_TEXTURE(UNIT, AtomicType.MATERIAL, STRING, TEXTURE),
	
	GET_NUMBER(NUMBER, AtomicType.MATERIAL, STRING),
	GET_INTEGER(NUMBER, AtomicType.MATERIAL, STRING),
	GET_COLOR(COLOR, AtomicType.MATERIAL, STRING),
	GET_TEXTURE(TEXTURE, AtomicType.MATERIAL, STRING),
	GET_KEYWORD(PROPOSITION, AtomicType.MATERIAL, STRING),
	
	
	SET_TRIGGER(UNIT, ENTITY, STRING),
	IN_STATE(PROPOSITION, ENTITY, STRING),
	
	READ_TRIGGERED(PROPOSITION, INPUT),
	READ_NUMBER(NUMBER, INPUT),
	READ_VECTOR(NUMBER2, INPUT),
	
	PLAY(UNIT, ENTITY, AtomicType.AUDIOCLIP),
	PAUSE(UNIT, ENTITY, AtomicType.AUDIOCLIP),
	UNPAUSE(UNIT, ENTITY, AtomicType.AUDIOCLIP),
	STOP(UNIT, ENTITY, AtomicType.AUDIOCLIP),
	
	PLAY_ONCE(UNIT, ENTITY, AtomicType.AUDIOCLIP),
	
	
	
	TO_QUATERNION(QUATERNION, NUMBER3),
	TO_NUMBER3(NUMBER3, QUATERNION),
	
	CLOSEST_POINT(NUMBER3, ENTITY, NUMBER3),
	ADD_FORCE(UNIT, ENTITY, NUMBER3),
	ADD_TORQUE(UNIT, ENTITY, NUMBER3),
	
	ASSIGNMENT(UNIT, A, A),
	;
	
	Type type;
	
	Function (Type returnType, Type... parameters) {
		this.type = new FunctionType(parameters, returnType);
	}
	
	public Type getType() {
		return type;
	}
}
