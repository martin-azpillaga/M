/*
 * generated by Xtext
 */
package m.serializer;

import com.google.inject.Inject;
import java.util.Set;
import m.cs.Access;
import m.cs.And;
import m.cs.Annotation;
import m.cs.Argument;
import m.cs.Assignment;
import m.cs.Bitwise;
import m.cs.Block;
import m.cs.Brackets;
import m.cs.Cast;
import m.cs.Comparison;
import m.cs.CsPackage;
import m.cs.Decrement;
import m.cs.Divide;
import m.cs.Else;
import m.cs.ElseIf;
import m.cs.Field;
import m.cs.File;
import m.cs.For;
import m.cs.If;
import m.cs.Increment;
import m.cs.Indexing;
import m.cs.Initialization;
import m.cs.InitializeVariable;
import m.cs.Label;
import m.cs.Lambda;
import m.cs.Member;
import m.cs.Method;
import m.cs.MethodCall;
import m.cs.Minus;
import m.cs.Modulus;
import m.cs.Not;
import m.cs.Or;
import m.cs.Plus;
import m.cs.QualifiedName;
import m.cs.Return;
import m.cs.Times;
import m.cs.Type;
import m.cs.TypeName;
import m.cs.Using;
import m.services.CSGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CsPackage.ACCESS:
				sequence_Access(context, (Access) semanticObject); 
				return; 
			case CsPackage.AND:
				sequence_Boolean1(context, (And) semanticObject); 
				return; 
			case CsPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case CsPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case CsPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case CsPackage.BITWISE:
				sequence_Bitwise(context, (Bitwise) semanticObject); 
				return; 
			case CsPackage.BLOCK:
				sequence_While(context, (Block) semanticObject); 
				return; 
			case CsPackage.BRACKETS:
				sequence_Primary(context, (Brackets) semanticObject); 
				return; 
			case CsPackage.CAST:
				sequence_Expression(context, (Cast) semanticObject); 
				return; 
			case CsPackage.COMPARISON:
				sequence_Boolean4(context, (Comparison) semanticObject); 
				return; 
			case CsPackage.DECREMENT:
				sequence_Unary(context, (Decrement) semanticObject); 
				return; 
			case CsPackage.DIVIDE:
				sequence_Multiplication(context, (Divide) semanticObject); 
				return; 
			case CsPackage.ELSE:
				sequence_Else(context, (Else) semanticObject); 
				return; 
			case CsPackage.ELSE_IF:
				sequence_ElseIf(context, (ElseIf) semanticObject); 
				return; 
			case CsPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case CsPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case CsPackage.FLOAT:
				sequence_Atomic(context, (m.cs.Float) semanticObject); 
				return; 
			case CsPackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case CsPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case CsPackage.INCREMENT:
				sequence_Unary(context, (Increment) semanticObject); 
				return; 
			case CsPackage.INDEXING:
				sequence_Portion(context, (Indexing) semanticObject); 
				return; 
			case CsPackage.INITIALIZATION:
				sequence_Portion(context, (Initialization) semanticObject); 
				return; 
			case CsPackage.INITIALIZE_VARIABLE:
				sequence_InitializeVariable(context, (InitializeVariable) semanticObject); 
				return; 
			case CsPackage.LABEL:
				sequence_Portion(context, (Label) semanticObject); 
				return; 
			case CsPackage.LAMBDA:
				sequence_Lambda(context, (Lambda) semanticObject); 
				return; 
			case CsPackage.LONG:
				sequence_Atomic(context, (m.cs.Long) semanticObject); 
				return; 
			case CsPackage.MEMBER:
				sequence_Member(context, (Member) semanticObject); 
				return; 
			case CsPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case CsPackage.METHOD_CALL:
				sequence_Portion(context, (MethodCall) semanticObject); 
				return; 
			case CsPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case CsPackage.MODULUS:
				sequence_Multiplication(context, (Modulus) semanticObject); 
				return; 
			case CsPackage.NOT:
				sequence_Boolean2(context, (Not) semanticObject); 
				return; 
			case CsPackage.OR:
				sequence_Boolean0(context, (Or) semanticObject); 
				return; 
			case CsPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case CsPackage.QUALIFIED_NAME:
				sequence_QualifiedName(context, (QualifiedName) semanticObject); 
				return; 
			case CsPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case CsPackage.STRING:
				sequence_Atomic(context, (m.cs.String) semanticObject); 
				return; 
			case CsPackage.TIMES:
				sequence_Multiplication(context, (Times) semanticObject); 
				return; 
			case CsPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case CsPackage.TYPE_NAME:
				sequence_TypeName(context, (TypeName) semanticObject); 
				return; 
			case CsPackage.USING:
				sequence_Using(context, (Using) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Access returns Access
	 *     Atomic returns Access
	 *     Expression returns Access
	 *     Boolean0 returns Access
	 *     Boolean0.Or_1_0 returns Access
	 *     Boolean1 returns Access
	 *     Boolean1.And_1_0 returns Access
	 *     Boolean2 returns Access
	 *     Boolean3 returns Access
	 *     Boolean4 returns Access
	 *     Boolean4.Comparison_1_0 returns Access
	 *     Addition returns Access
	 *     Addition.Plus_1_0_0_0 returns Access
	 *     Addition.Minus_1_0_1_0 returns Access
	 *     Multiplication returns Access
	 *     Multiplication.Times_1_0_0_0 returns Access
	 *     Multiplication.Divide_1_0_1_0 returns Access
	 *     Multiplication.Modulus_1_0_2_0 returns Access
	 *     Bitwise returns Access
	 *     Bitwise.Bitwise_1_0 returns Access
	 *     Unary returns Access
	 *     Unary.Increment_1_0_0 returns Access
	 *     Unary.Decrement_1_1_0 returns Access
	 *     Primary returns Access
	 *
	 * Constraint:
	 *     (new?='new'? ref?='ref'? portions+=Portion portions+=Portion*)
	 */
	protected void sequence_Access(ISerializationContext context, Access semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Boolean0 returns Minus
	 *     Boolean0.Or_1_0 returns Minus
	 *     Boolean1 returns Minus
	 *     Boolean1.And_1_0 returns Minus
	 *     Boolean2 returns Minus
	 *     Boolean3 returns Minus
	 *     Boolean4 returns Minus
	 *     Boolean4.Comparison_1_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Boolean0 returns Plus
	 *     Boolean0.Or_1_0 returns Plus
	 *     Boolean1 returns Plus
	 *     Boolean1.And_1_0 returns Plus
	 *     Boolean2 returns Plus
	 *     Boolean3 returns Plus
	 *     Boolean4 returns Plus
	 *     Boolean4.Comparison_1_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (function=TypeName (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     (annotations+=Annotation* ref?='ref'? type=TypeName name=ID)
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     ((var?='var' | type=TypeName)? access=Access ((assignmentType=AssignmentType expression=Expression) | increment?='++' | decrement?='--')?)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns Float
	 *     Expression returns Float
	 *     Boolean0 returns Float
	 *     Boolean0.Or_1_0 returns Float
	 *     Boolean1 returns Float
	 *     Boolean1.And_1_0 returns Float
	 *     Boolean2 returns Float
	 *     Boolean3 returns Float
	 *     Boolean4 returns Float
	 *     Boolean4.Comparison_1_0 returns Float
	 *     Addition returns Float
	 *     Addition.Plus_1_0_0_0 returns Float
	 *     Addition.Minus_1_0_1_0 returns Float
	 *     Multiplication returns Float
	 *     Multiplication.Times_1_0_0_0 returns Float
	 *     Multiplication.Divide_1_0_1_0 returns Float
	 *     Multiplication.Modulus_1_0_2_0 returns Float
	 *     Bitwise returns Float
	 *     Bitwise.Bitwise_1_0 returns Float
	 *     Unary returns Float
	 *     Unary.Increment_1_0_0 returns Float
	 *     Unary.Decrement_1_1_0 returns Float
	 *     Primary returns Float
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_Atomic(ISerializationContext context, m.cs.Float semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueFLOATTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns Long
	 *     Expression returns Long
	 *     Boolean0 returns Long
	 *     Boolean0.Or_1_0 returns Long
	 *     Boolean1 returns Long
	 *     Boolean1.And_1_0 returns Long
	 *     Boolean2 returns Long
	 *     Boolean3 returns Long
	 *     Boolean4 returns Long
	 *     Boolean4.Comparison_1_0 returns Long
	 *     Addition returns Long
	 *     Addition.Plus_1_0_0_0 returns Long
	 *     Addition.Minus_1_0_1_0 returns Long
	 *     Multiplication returns Long
	 *     Multiplication.Times_1_0_0_0 returns Long
	 *     Multiplication.Divide_1_0_1_0 returns Long
	 *     Multiplication.Modulus_1_0_2_0 returns Long
	 *     Bitwise returns Long
	 *     Bitwise.Bitwise_1_0 returns Long
	 *     Unary returns Long
	 *     Unary.Increment_1_0_0 returns Long
	 *     Unary.Decrement_1_1_0 returns Long
	 *     Primary returns Long
	 *
	 * Constraint:
	 *     value=LONG
	 */
	protected void sequence_Atomic(ISerializationContext context, m.cs.Long semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.LONG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.LONG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueLONGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atomic returns String
	 *     Expression returns String
	 *     Boolean0 returns String
	 *     Boolean0.Or_1_0 returns String
	 *     Boolean1 returns String
	 *     Boolean1.And_1_0 returns String
	 *     Boolean2 returns String
	 *     Boolean3 returns String
	 *     Boolean4 returns String
	 *     Boolean4.Comparison_1_0 returns String
	 *     Addition returns String
	 *     Addition.Plus_1_0_0_0 returns String
	 *     Addition.Minus_1_0_1_0 returns String
	 *     Multiplication returns String
	 *     Multiplication.Times_1_0_0_0 returns String
	 *     Multiplication.Divide_1_0_1_0 returns String
	 *     Multiplication.Modulus_1_0_2_0 returns String
	 *     Bitwise returns String
	 *     Bitwise.Bitwise_1_0 returns String
	 *     Unary returns String
	 *     Unary.Increment_1_0_0 returns String
	 *     Unary.Decrement_1_1_0 returns String
	 *     Primary returns String
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, m.cs.String semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bitwise
	 *     Boolean0 returns Bitwise
	 *     Boolean0.Or_1_0 returns Bitwise
	 *     Boolean1 returns Bitwise
	 *     Boolean1.And_1_0 returns Bitwise
	 *     Boolean2 returns Bitwise
	 *     Boolean3 returns Bitwise
	 *     Boolean4 returns Bitwise
	 *     Boolean4.Comparison_1_0 returns Bitwise
	 *     Addition returns Bitwise
	 *     Addition.Plus_1_0_0_0 returns Bitwise
	 *     Addition.Minus_1_0_1_0 returns Bitwise
	 *     Multiplication returns Bitwise
	 *     Multiplication.Times_1_0_0_0 returns Bitwise
	 *     Multiplication.Divide_1_0_1_0 returns Bitwise
	 *     Multiplication.Modulus_1_0_2_0 returns Bitwise
	 *     Bitwise returns Bitwise
	 *     Bitwise.Bitwise_1_0 returns Bitwise
	 *
	 * Constraint:
	 *     (left=Bitwise_Bitwise_1_0 (op='&' | op='|' | op='~') right=Unary)
	 */
	protected void sequence_Bitwise(ISerializationContext context, Bitwise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Boolean0 returns Or
	 *     Boolean0.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Boolean0_Or_1_0 right=Boolean1)
	 */
	protected void sequence_Boolean0(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolean0Access().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBoolean0Access().getRightBoolean1ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Boolean0 returns And
	 *     Boolean0.Or_1_0 returns And
	 *     Boolean1 returns And
	 *     Boolean1.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=Boolean1_And_1_0 right=Boolean2)
	 */
	protected void sequence_Boolean1(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolean1Access().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBoolean1Access().getRightBoolean2ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Boolean0 returns Not
	 *     Boolean0.Or_1_0 returns Not
	 *     Boolean1 returns Not
	 *     Boolean1.And_1_0 returns Not
	 *     Boolean2 returns Not
	 *
	 * Constraint:
	 *     expression=Boolean3
	 */
	protected void sequence_Boolean2(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolean2Access().getExpressionBoolean3ParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Boolean0 returns Comparison
	 *     Boolean0.Or_1_0 returns Comparison
	 *     Boolean1 returns Comparison
	 *     Boolean1.And_1_0 returns Comparison
	 *     Boolean2 returns Comparison
	 *     Boolean3 returns Comparison
	 *     Boolean4 returns Comparison
	 *
	 * Constraint:
	 *     (left=Boolean4_Comparison_1_0 type=RelationType right=Addition)
	 */
	protected void sequence_Boolean4(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.COMPARISON__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.COMPARISON__TYPE));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolean4Access().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBoolean4Access().getTypeRelationTypeEnumRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getBoolean4Access().getRightAdditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElseIf returns ElseIf
	 *
	 * Constraint:
	 *     (expression=Expression commands+=Command*)
	 */
	protected void sequence_ElseIf(ISerializationContext context, ElseIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Else returns Else
	 *
	 * Constraint:
	 *     commands+=Command*
	 */
	protected void sequence_Else(ISerializationContext context, Else semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Cast
	 *
	 * Constraint:
	 *     (type=TypeName expression=Boolean0)
	 */
	protected void sequence_Expression(ISerializationContext context, Cast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.CAST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.CAST__TYPE));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.CAST__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.CAST__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getTypeTypeNameParserRuleCall_0_0_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionBoolean0ParserRuleCall_0_0_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (type=TypeName name=ID)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.FIELD__TYPE));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeNameParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     ((usings+=Using+ types+=Member+) | types+=Member+)?
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns For
	 *     For returns For
	 *
	 * Constraint:
	 *     (initialization=Assignment condition=Expression increment=Assignment commands+=Command*)
	 */
	protected void sequence_For(ISerializationContext context, For semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (expression=Expression commands+=Command* elseIfs+=ElseIf* else=Else?)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitializeVariable returns InitializeVariable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 */
	protected void sequence_InitializeVariable(ISerializationContext context, InitializeVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.INITIALIZE_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.INITIALIZE_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.INITIALIZE_VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.INITIALIZE_VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitializeVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitializeVariableAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Lambda returns Lambda
	 *     Expression returns Lambda
	 *
	 * Constraint:
	 *     (arguments+=Argument arguments+=Argument* commands+=Command*)
	 */
	protected void sequence_Lambda(ISerializationContext context, Lambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Member
	 *
	 * Constraint:
	 *     (annotations+=Annotation* visibility=Visibility static?='static'? (value=Type | value=Method | value=Field))
	 */
	protected void sequence_Member(ISerializationContext context, Member semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     (
	 *         override?='override'? 
	 *         (type=TypeName | (implicit?='implicit' operator?='operator')) 
	 *         name=ID 
	 *         (generics+=TypeName generics+=TypeName*)? 
	 *         (arguments+=Argument arguments+=Argument*)? 
	 *         commands+=Command*
	 *     )
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Boolean0 returns Divide
	 *     Boolean0.Or_1_0 returns Divide
	 *     Boolean1 returns Divide
	 *     Boolean1.And_1_0 returns Divide
	 *     Boolean2 returns Divide
	 *     Boolean3 returns Divide
	 *     Boolean4 returns Divide
	 *     Boolean4.Comparison_1_0 returns Divide
	 *     Addition returns Divide
	 *     Addition.Plus_1_0_0_0 returns Divide
	 *     Addition.Minus_1_0_1_0 returns Divide
	 *     Multiplication returns Divide
	 *     Multiplication.Times_1_0_0_0 returns Divide
	 *     Multiplication.Divide_1_0_1_0 returns Divide
	 *     Multiplication.Modulus_1_0_2_0 returns Divide
	 *
	 * Constraint:
	 *     (left=Multiplication_Divide_1_0_1_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivideLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Modulus
	 *     Boolean0 returns Modulus
	 *     Boolean0.Or_1_0 returns Modulus
	 *     Boolean1 returns Modulus
	 *     Boolean1.And_1_0 returns Modulus
	 *     Boolean2 returns Modulus
	 *     Boolean3 returns Modulus
	 *     Boolean4 returns Modulus
	 *     Boolean4.Comparison_1_0 returns Modulus
	 *     Addition returns Modulus
	 *     Addition.Plus_1_0_0_0 returns Modulus
	 *     Addition.Minus_1_0_1_0 returns Modulus
	 *     Multiplication returns Modulus
	 *     Multiplication.Times_1_0_0_0 returns Modulus
	 *     Multiplication.Divide_1_0_1_0 returns Modulus
	 *     Multiplication.Modulus_1_0_2_0 returns Modulus
	 *
	 * Constraint:
	 *     (left=Multiplication_Modulus_1_0_2_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Modulus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.MODULUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.MODULUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.MODULUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.MODULUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getModulusLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Times
	 *     Boolean0 returns Times
	 *     Boolean0.Or_1_0 returns Times
	 *     Boolean1 returns Times
	 *     Boolean1.And_1_0 returns Times
	 *     Boolean2 returns Times
	 *     Boolean3 returns Times
	 *     Boolean4 returns Times
	 *     Boolean4.Comparison_1_0 returns Times
	 *     Addition returns Times
	 *     Addition.Plus_1_0_0_0 returns Times
	 *     Addition.Minus_1_0_1_0 returns Times
	 *     Multiplication returns Times
	 *     Multiplication.Times_1_0_0_0 returns Times
	 *     Multiplication.Divide_1_0_1_0 returns Times
	 *     Multiplication.Modulus_1_0_2_0 returns Times
	 *
	 * Constraint:
	 *     (left=Multiplication_Times_1_0_0_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Times semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.TIMES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.TIMES__LEFT));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.TIMES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.TIMES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getTimesLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Portion returns Indexing
	 *
	 * Constraint:
	 *     (name=ID index=Expression)
	 */
	protected void sequence_Portion(ISerializationContext context, Indexing semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.PORTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.PORTION__NAME));
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.INDEXING__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.INDEXING__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortionAccess().getNameIDTerminalRuleCall_3_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPortionAccess().getIndexExpressionParserRuleCall_3_3_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Portion returns Initialization
	 *
	 * Constraint:
	 *     (name=ID (initializations+=InitializeVariable initializations+=InitializeVariable*)?)
	 */
	protected void sequence_Portion(ISerializationContext context, Initialization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Portion returns Label
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Portion(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.PORTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.PORTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortionAccess().getNameIDTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Portion returns MethodCall
	 *
	 * Constraint:
	 *     (name=ID generics+=TypeName? (expressions+=Expression expressions+=Expression*)?)
	 */
	protected void sequence_Portion(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Brackets
	 *     Boolean0 returns Brackets
	 *     Boolean0.Or_1_0 returns Brackets
	 *     Boolean1 returns Brackets
	 *     Boolean1.And_1_0 returns Brackets
	 *     Boolean2 returns Brackets
	 *     Boolean3 returns Brackets
	 *     Boolean4 returns Brackets
	 *     Boolean4.Comparison_1_0 returns Brackets
	 *     Addition returns Brackets
	 *     Addition.Plus_1_0_0_0 returns Brackets
	 *     Addition.Minus_1_0_1_0 returns Brackets
	 *     Multiplication returns Brackets
	 *     Multiplication.Times_1_0_0_0 returns Brackets
	 *     Multiplication.Divide_1_0_1_0 returns Brackets
	 *     Multiplication.Modulus_1_0_2_0 returns Brackets
	 *     Bitwise returns Brackets
	 *     Bitwise.Bitwise_1_0 returns Brackets
	 *     Unary returns Brackets
	 *     Unary.Increment_1_0_0 returns Brackets
	 *     Unary.Decrement_1_1_0 returns Brackets
	 *     Primary returns Brackets
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Brackets semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.BRACKETS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.BRACKETS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QualifiedName returns QualifiedName
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 */
	protected void sequence_QualifiedName(ISerializationContext context, QualifiedName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.COMMAND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.COMMAND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeName returns TypeName
	 *
	 * Constraint:
	 *     (name=QualifiedName (generics+=QualifiedName generics+=QualifiedName*)?)
	 */
	protected void sequence_TypeName(ISerializationContext context, TypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (sealed?='sealed'? type=TypeEnum name=TypeName (superTypes+=TypeName superTypes+=TypeName*)? members+=Member*)
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Decrement
	 *     Boolean0 returns Decrement
	 *     Boolean0.Or_1_0 returns Decrement
	 *     Boolean1 returns Decrement
	 *     Boolean1.And_1_0 returns Decrement
	 *     Boolean2 returns Decrement
	 *     Boolean3 returns Decrement
	 *     Boolean4 returns Decrement
	 *     Boolean4.Comparison_1_0 returns Decrement
	 *     Addition returns Decrement
	 *     Addition.Plus_1_0_0_0 returns Decrement
	 *     Addition.Minus_1_0_1_0 returns Decrement
	 *     Multiplication returns Decrement
	 *     Multiplication.Times_1_0_0_0 returns Decrement
	 *     Multiplication.Divide_1_0_1_0 returns Decrement
	 *     Multiplication.Modulus_1_0_2_0 returns Decrement
	 *     Bitwise returns Decrement
	 *     Bitwise.Bitwise_1_0 returns Decrement
	 *     Unary returns Decrement
	 *
	 * Constraint:
	 *     left=Unary_Decrement_1_1_0
	 */
	protected void sequence_Unary(ISerializationContext context, Decrement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.DECREMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.DECREMENT__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getDecrementLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Increment
	 *     Boolean0 returns Increment
	 *     Boolean0.Or_1_0 returns Increment
	 *     Boolean1 returns Increment
	 *     Boolean1.And_1_0 returns Increment
	 *     Boolean2 returns Increment
	 *     Boolean3 returns Increment
	 *     Boolean4 returns Increment
	 *     Boolean4.Comparison_1_0 returns Increment
	 *     Addition returns Increment
	 *     Addition.Plus_1_0_0_0 returns Increment
	 *     Addition.Minus_1_0_1_0 returns Increment
	 *     Multiplication returns Increment
	 *     Multiplication.Times_1_0_0_0 returns Increment
	 *     Multiplication.Divide_1_0_1_0 returns Increment
	 *     Multiplication.Modulus_1_0_2_0 returns Increment
	 *     Bitwise returns Increment
	 *     Bitwise.Bitwise_1_0 returns Increment
	 *     Unary returns Increment
	 *
	 * Constraint:
	 *     left=Unary_Increment_1_0_0
	 */
	protected void sequence_Unary(ISerializationContext context, Increment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.INCREMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.INCREMENT__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getIncrementLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Using returns Using
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Using(ISerializationContext context, Using semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CsPackage.Literals.USING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CsPackage.Literals.USING__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUsingAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Block
	 *     While returns Block
	 *
	 * Constraint:
	 *     (expression=Expression commands+=Command*)
	 */
	protected void sequence_While(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
