/*
 * generated by Xtext
 */
package m.serializer;

import com.google.inject.Inject;
import java.util.Set;
import m.services.YAMLGrammarAccess;
import m.yaml.Document;
import m.yaml.File;
import m.yaml.Guid;
import m.yaml.InlineList;
import m.yaml.InlineMap;
import m.yaml.InlineSemicolonList;
import m.yaml.KeyValue;
import m.yaml.KeyValueList;
import m.yaml.Map;
import m.yaml.Word;
import m.yaml.YamlPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class YAMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private YAMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == YamlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case YamlPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case YamlPackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case YamlPackage.FLOAT:
				sequence_Element(context, (m.yaml.Float) semanticObject); 
				return; 
			case YamlPackage.GUID:
				sequence_Element(context, (Guid) semanticObject); 
				return; 
			case YamlPackage.INLINE_LIST:
				sequence_InlineList(context, (InlineList) semanticObject); 
				return; 
			case YamlPackage.INLINE_MAP:
				sequence_InlineMap(context, (InlineMap) semanticObject); 
				return; 
			case YamlPackage.INLINE_SEMICOLON_LIST:
				sequence_InlineSemicolonList(context, (InlineSemicolonList) semanticObject); 
				return; 
			case YamlPackage.KEY_VALUE:
				sequence_KeyValue(context, (KeyValue) semanticObject); 
				return; 
			case YamlPackage.KEY_VALUE_LIST:
				sequence_KeyValueList(context, (KeyValueList) semanticObject); 
				return; 
			case YamlPackage.LONG:
				sequence_Element(context, (m.yaml.Long) semanticObject); 
				return; 
			case YamlPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case YamlPackage.WORD:
				sequence_Element(context, (Word) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Node returns Document
	 *     Document returns Document
	 *
	 * Constraint:
	 *     (tag=L id=L value=Map)
	 */
	protected void sequence_Document(ISerializationContext context, Document semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.DOCUMENT__TAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.DOCUMENT__TAG));
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.DOCUMENT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.DOCUMENT__ID));
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.DOCUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.DOCUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDocumentAccess().getTagLTerminalRuleCall_4_0(), semanticObject.getTag());
		feeder.accept(grammarAccess.getDocumentAccess().getIdLTerminalRuleCall_7_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getDocumentAccess().getValueMapParserRuleCall_9_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Float
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_Element(ISerializationContext context, m.yaml.Float semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getValueFLOATTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Guid
	 *
	 * Constraint:
	 *     value=GUID
	 */
	protected void sequence_Element(ISerializationContext context, Guid semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.GUID__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.GUID__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getValueGUIDTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Long
	 *
	 * Constraint:
	 *     value=L
	 */
	protected void sequence_Element(ISerializationContext context, m.yaml.Long semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.LONG__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.LONG__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getValueLTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Word
	 *
	 * Constraint:
	 *     value=WORD
	 */
	protected void sequence_Element(ISerializationContext context, Word semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, YamlPackage.Literals.WORD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, YamlPackage.Literals.WORD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getValueWORDTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     ((version=Version tags+=Tag)? nodes+=Node*)
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns InlineList
	 *     InlineList returns InlineList
	 *
	 * Constraint:
	 *     (elements+=Element elements+=Element*)?
	 */
	protected void sequence_InlineList(ISerializationContext context, InlineList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns InlineMap
	 *     InlineMap returns InlineMap
	 *
	 * Constraint:
	 *     (values+=KeyValue values+=KeyValue*)?
	 */
	protected void sequence_InlineMap(ISerializationContext context, InlineMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns InlineSemicolonList
	 *     InlineSemicolonList returns InlineSemicolonList
	 *
	 * Constraint:
	 *     (elements+=WORD elements+=WORD elements+=WORD*)
	 */
	protected void sequence_InlineSemicolonList(ISerializationContext context, InlineSemicolonList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns KeyValueList
	 *     Value returns KeyValueList
	 *     KeyValueList returns KeyValueList
	 *
	 * Constraint:
	 *     (name=WORD (values+=KeyValue | values+=Element) values+=Element? (values+=KeyValue? values+=Element?)*)
	 */
	protected void sequence_KeyValueList(ISerializationContext context, KeyValueList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns KeyValue
	 *     Value returns KeyValue
	 *     KeyValue returns KeyValue
	 *
	 * Constraint:
	 *     (key=WORD value=Element?)
	 */
	protected void sequence_KeyValue(ISerializationContext context, KeyValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Map
	 *     Value returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (key=WORD body+=Value body+=Value*)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
