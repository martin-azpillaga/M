/*
 * generated by Xtext
 */
package m.serializer;

import com.google.inject.Inject;
import java.util.Set;
import m.m.Access;
import m.m.And;
import m.m.Assignment;
import m.m.Bitwise;
import m.m.BitwiseNegate;
import m.m.Brackets;
import m.m.Branch;
import m.m.Call;
import m.m.Comparison;
import m.m.Component;
import m.m.Condition;
import m.m.Decrement;
import m.m.Divide;
import m.m.Entity;
import m.m.Game;
import m.m.Increment;
import m.m.Loop;
import m.m.MPackage;
import m.m.Minus;
import m.m.Modulus;
import m.m.Not;
import m.m.Or;
import m.m.Plus;
import m.m.Times;
import m.m.Vector;
import m.m.Word;
import m.services.MGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MPackage.ACCESS:
				sequence_Access(context, (Access) semanticObject); 
				return; 
			case MPackage.AND:
				sequence_Expression1(context, (And) semanticObject); 
				return; 
			case MPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MPackage.BITWISE:
				sequence_Bitwise(context, (Bitwise) semanticObject); 
				return; 
			case MPackage.BITWISE_NEGATE:
				sequence_Unary(context, (BitwiseNegate) semanticObject); 
				return; 
			case MPackage.BRACKETS:
				sequence_Primary(context, (Brackets) semanticObject); 
				return; 
			case MPackage.BRANCH:
				sequence_Branch(context, (Branch) semanticObject); 
				return; 
			case MPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case MPackage.COMPARISON:
				sequence_AtomicB(context, (Comparison) semanticObject); 
				return; 
			case MPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case MPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MPackage.DECREMENT:
				sequence_Unary(context, (Decrement) semanticObject); 
				return; 
			case MPackage.DIVIDE:
				sequence_Multiplication(context, (Divide) semanticObject); 
				return; 
			case MPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case MPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case MPackage.INCREMENT:
				sequence_Unary(context, (Increment) semanticObject); 
				return; 
			case MPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case MPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case MPackage.MODULUS:
				sequence_Multiplication(context, (Modulus) semanticObject); 
				return; 
			case MPackage.NOT:
				sequence_PrimaryB(context, (Not) semanticObject); 
				return; 
			case MPackage.OR:
				sequence_Expression(context, (Or) semanticObject); 
				return; 
			case MPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case MPackage.SYSTEM:
				sequence_System(context, (m.m.System) semanticObject); 
				return; 
			case MPackage.TIMES:
				sequence_Multiplication(context, (Times) semanticObject); 
				return; 
			case MPackage.VECTOR:
				sequence_Vector(context, (Vector) semanticObject); 
				return; 
			case MPackage.WORD:
				sequence_Word(context, (Word) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Access returns Access
	 *     Expression returns Access
	 *     Expression.Or_1_0 returns Access
	 *     Expression1 returns Access
	 *     Expression1.And_1_0 returns Access
	 *     PrimaryB returns Access
	 *     AtomicB returns Access
	 *     AtomicB.Comparison_1_0 returns Access
	 *     Addition returns Access
	 *     Addition.Plus_1_0_0_0 returns Access
	 *     Addition.Minus_1_0_1_0 returns Access
	 *     Multiplication returns Access
	 *     Multiplication.Times_1_0_0_0 returns Access
	 *     Multiplication.Divide_1_0_1_0 returns Access
	 *     Multiplication.Modulus_1_0_2_0 returns Access
	 *     Bitwise returns Access
	 *     Bitwise.Bitwise_1_0 returns Access
	 *     Unary returns Access
	 *     Unary.Increment_1_1_0_0 returns Access
	 *     Unary.Decrement_1_1_1_0 returns Access
	 *     Primary returns Access
	 *
	 * Constraint:
	 *     (names+=ID names+=ID*)
	 */
	protected void sequence_Access(ISerializationContext context, Access semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Expression.Or_1_0 returns Minus
	 *     Expression1 returns Minus
	 *     Expression1.And_1_0 returns Minus
	 *     PrimaryB returns Minus
	 *     AtomicB returns Minus
	 *     AtomicB.Comparison_1_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Expression.Or_1_0 returns Plus
	 *     Expression1 returns Plus
	 *     Expression1.And_1_0 returns Plus
	 *     PrimaryB returns Plus
	 *     AtomicB returns Plus
	 *     AtomicB.Comparison_1_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (access=Access type=AssignmentType expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.ASSIGNMENT__ACCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.ASSIGNMENT__ACCESS));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.ASSIGNMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.ASSIGNMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAccessAccessParserRuleCall_0_0(), semanticObject.getAccess());
		feeder.accept(grammarAccess.getAssignmentAccess().getTypeAssignmentTypeEnumRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Expression.Or_1_0 returns Comparison
	 *     Expression1 returns Comparison
	 *     Expression1.And_1_0 returns Comparison
	 *     PrimaryB returns Comparison
	 *     AtomicB returns Comparison
	 *
	 * Constraint:
	 *     (left=AtomicB_Comparison_1_0 type=RelationType right=Addition)
	 */
	protected void sequence_AtomicB(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.COMPARISON__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.COMPARISON__TYPE));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicBAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAtomicBAccess().getTypeRelationTypeEnumRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAtomicBAccess().getRightAdditionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Bitwise
	 *     Expression.Or_1_0 returns Bitwise
	 *     Expression1 returns Bitwise
	 *     Expression1.And_1_0 returns Bitwise
	 *     PrimaryB returns Bitwise
	 *     AtomicB returns Bitwise
	 *     AtomicB.Comparison_1_0 returns Bitwise
	 *     Addition returns Bitwise
	 *     Addition.Plus_1_0_0_0 returns Bitwise
	 *     Addition.Minus_1_0_1_0 returns Bitwise
	 *     Multiplication returns Bitwise
	 *     Multiplication.Times_1_0_0_0 returns Bitwise
	 *     Multiplication.Divide_1_0_1_0 returns Bitwise
	 *     Multiplication.Modulus_1_0_2_0 returns Bitwise
	 *     Bitwise returns Bitwise
	 *     Bitwise.Bitwise_1_0 returns Bitwise
	 *
	 * Constraint:
	 *     (left=Bitwise_Bitwise_1_0 (op='&' | op='|' | op='^' | op='<<' | op='>>') right=Unary)
	 */
	protected void sequence_Bitwise(ISerializationContext context, Bitwise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Branch
	 *     Branch returns Branch
	 *
	 * Constraint:
	 *     (if=Condition elseIfs+=Condition* commands+=Command*)
	 */
	protected void sequence_Branch(ISerializationContext context, Branch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Call
	 *     Call returns Call
	 *     Expression returns Call
	 *     Expression.Or_1_0 returns Call
	 *     Expression1 returns Call
	 *     Expression1.And_1_0 returns Call
	 *     PrimaryB returns Call
	 *     AtomicB returns Call
	 *     AtomicB.Comparison_1_0 returns Call
	 *     Addition returns Call
	 *     Addition.Plus_1_0_0_0 returns Call
	 *     Addition.Minus_1_0_1_0 returns Call
	 *     Multiplication returns Call
	 *     Multiplication.Times_1_0_0_0 returns Call
	 *     Multiplication.Divide_1_0_1_0 returns Call
	 *     Multiplication.Modulus_1_0_2_0 returns Call
	 *     Bitwise returns Call
	 *     Bitwise.Bitwise_1_0 returns Call
	 *     Unary returns Call
	 *     Unary.Increment_1_1_0_0 returns Call
	 *     Unary.Decrement_1_1_1_0 returns Call
	 *     Primary returns Call
	 *
	 * Constraint:
	 *     (name=ID parameters+=Expression parameters+=Expression*)
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ID value=Value?)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (condition=Expression commands+=Command*)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name+=ID+ base+=ID* (components+=Component components+=Component*)? entities+=Entity*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Expression.Or_1_0 returns And
	 *     Expression1 returns And
	 *     Expression1.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=Expression1_And_1_0 right=PrimaryB)
	 */
	protected void sequence_Expression1(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpression1Access().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpression1Access().getRightPrimaryBParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Expression.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Expression_Or_1_0 right=Expression1)
	 */
	protected void sequence_Expression(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightExpression1ParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (entities+=Entity | systems+=System)+
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (entity=ID constraints+=ID* commands+=Command+)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Expression.Or_1_0 returns Divide
	 *     Expression1 returns Divide
	 *     Expression1.And_1_0 returns Divide
	 *     PrimaryB returns Divide
	 *     AtomicB returns Divide
	 *     AtomicB.Comparison_1_0 returns Divide
	 *     Addition returns Divide
	 *     Addition.Plus_1_0_0_0 returns Divide
	 *     Addition.Minus_1_0_1_0 returns Divide
	 *     Multiplication returns Divide
	 *     Multiplication.Times_1_0_0_0 returns Divide
	 *     Multiplication.Divide_1_0_1_0 returns Divide
	 *     Multiplication.Modulus_1_0_2_0 returns Divide
	 *
	 * Constraint:
	 *     (left=Multiplication_Divide_1_0_1_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivideLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Modulus
	 *     Expression.Or_1_0 returns Modulus
	 *     Expression1 returns Modulus
	 *     Expression1.And_1_0 returns Modulus
	 *     PrimaryB returns Modulus
	 *     AtomicB returns Modulus
	 *     AtomicB.Comparison_1_0 returns Modulus
	 *     Addition returns Modulus
	 *     Addition.Plus_1_0_0_0 returns Modulus
	 *     Addition.Minus_1_0_1_0 returns Modulus
	 *     Multiplication returns Modulus
	 *     Multiplication.Times_1_0_0_0 returns Modulus
	 *     Multiplication.Divide_1_0_1_0 returns Modulus
	 *     Multiplication.Modulus_1_0_2_0 returns Modulus
	 *
	 * Constraint:
	 *     (left=Multiplication_Modulus_1_0_2_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Modulus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.MODULUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.MODULUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.MODULUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.MODULUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getModulusLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Times
	 *     Expression.Or_1_0 returns Times
	 *     Expression1 returns Times
	 *     Expression1.And_1_0 returns Times
	 *     PrimaryB returns Times
	 *     AtomicB returns Times
	 *     AtomicB.Comparison_1_0 returns Times
	 *     Addition returns Times
	 *     Addition.Plus_1_0_0_0 returns Times
	 *     Addition.Minus_1_0_1_0 returns Times
	 *     Multiplication returns Times
	 *     Multiplication.Times_1_0_0_0 returns Times
	 *     Multiplication.Divide_1_0_1_0 returns Times
	 *     Multiplication.Modulus_1_0_2_0 returns Times
	 *
	 * Constraint:
	 *     (left=Multiplication_Times_1_0_0_0 right=Bitwise)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Times semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.TIMES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.TIMES__LEFT));
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.TIMES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.TIMES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getTimesLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightBitwiseParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Expression.Or_1_0 returns Not
	 *     Expression1 returns Not
	 *     Expression1.And_1_0 returns Not
	 *     PrimaryB returns Not
	 *
	 * Constraint:
	 *     expression=AtomicB
	 */
	protected void sequence_PrimaryB(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryBAccess().getExpressionAtomicBParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Brackets
	 *     Expression.Or_1_0 returns Brackets
	 *     Expression1 returns Brackets
	 *     Expression1.And_1_0 returns Brackets
	 *     PrimaryB returns Brackets
	 *     AtomicB returns Brackets
	 *     AtomicB.Comparison_1_0 returns Brackets
	 *     Addition returns Brackets
	 *     Addition.Plus_1_0_0_0 returns Brackets
	 *     Addition.Minus_1_0_1_0 returns Brackets
	 *     Multiplication returns Brackets
	 *     Multiplication.Times_1_0_0_0 returns Brackets
	 *     Multiplication.Divide_1_0_1_0 returns Brackets
	 *     Multiplication.Modulus_1_0_2_0 returns Brackets
	 *     Bitwise returns Brackets
	 *     Bitwise.Bitwise_1_0 returns Brackets
	 *     Unary returns Brackets
	 *     Unary.Increment_1_1_0_0 returns Brackets
	 *     Unary.Decrement_1_1_1_0 returns Brackets
	 *     Primary returns Brackets
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Brackets semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.BRACKETS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.BRACKETS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionExpressionParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=ID commands+=Command+)
	 */
	protected void sequence_System(ISerializationContext context, m.m.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitwiseNegate
	 *     Expression.Or_1_0 returns BitwiseNegate
	 *     Expression1 returns BitwiseNegate
	 *     Expression1.And_1_0 returns BitwiseNegate
	 *     PrimaryB returns BitwiseNegate
	 *     AtomicB returns BitwiseNegate
	 *     AtomicB.Comparison_1_0 returns BitwiseNegate
	 *     Addition returns BitwiseNegate
	 *     Addition.Plus_1_0_0_0 returns BitwiseNegate
	 *     Addition.Minus_1_0_1_0 returns BitwiseNegate
	 *     Multiplication returns BitwiseNegate
	 *     Multiplication.Times_1_0_0_0 returns BitwiseNegate
	 *     Multiplication.Divide_1_0_1_0 returns BitwiseNegate
	 *     Multiplication.Modulus_1_0_2_0 returns BitwiseNegate
	 *     Bitwise returns BitwiseNegate
	 *     Bitwise.Bitwise_1_0 returns BitwiseNegate
	 *     Unary returns BitwiseNegate
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Unary(ISerializationContext context, BitwiseNegate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.BITWISE_NEGATE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.BITWISE_NEGATE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getExpressionPrimaryParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Decrement
	 *     Expression.Or_1_0 returns Decrement
	 *     Expression1 returns Decrement
	 *     Expression1.And_1_0 returns Decrement
	 *     PrimaryB returns Decrement
	 *     AtomicB returns Decrement
	 *     AtomicB.Comparison_1_0 returns Decrement
	 *     Addition returns Decrement
	 *     Addition.Plus_1_0_0_0 returns Decrement
	 *     Addition.Minus_1_0_1_0 returns Decrement
	 *     Multiplication returns Decrement
	 *     Multiplication.Times_1_0_0_0 returns Decrement
	 *     Multiplication.Divide_1_0_1_0 returns Decrement
	 *     Multiplication.Modulus_1_0_2_0 returns Decrement
	 *     Bitwise returns Decrement
	 *     Bitwise.Bitwise_1_0 returns Decrement
	 *     Unary returns Decrement
	 *
	 * Constraint:
	 *     expression=Unary_Decrement_1_1_1_0
	 */
	protected void sequence_Unary(ISerializationContext context, Decrement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.DECREMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.DECREMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getDecrementExpressionAction_1_1_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Increment
	 *     Expression.Or_1_0 returns Increment
	 *     Expression1 returns Increment
	 *     Expression1.And_1_0 returns Increment
	 *     PrimaryB returns Increment
	 *     AtomicB returns Increment
	 *     AtomicB.Comparison_1_0 returns Increment
	 *     Addition returns Increment
	 *     Addition.Plus_1_0_0_0 returns Increment
	 *     Addition.Minus_1_0_1_0 returns Increment
	 *     Multiplication returns Increment
	 *     Multiplication.Times_1_0_0_0 returns Increment
	 *     Multiplication.Divide_1_0_1_0 returns Increment
	 *     Multiplication.Modulus_1_0_2_0 returns Increment
	 *     Bitwise returns Increment
	 *     Bitwise.Bitwise_1_0 returns Increment
	 *     Unary returns Increment
	 *
	 * Constraint:
	 *     expression=Unary_Increment_1_1_0_0
	 */
	protected void sequence_Unary(ISerializationContext context, Increment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MPackage.Literals.INCREMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MPackage.Literals.INCREMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getIncrementExpressionAction_1_1_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Vector
	 *     Vector returns Vector
	 *
	 * Constraint:
	 *     numbers+=REAL+
	 */
	protected void sequence_Vector(ISerializationContext context, Vector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Word
	 *     Word returns Word
	 *
	 * Constraint:
	 *     values+=ID+
	 */
	protected void sequence_Word(ISerializationContext context, Word semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
