grammar m.CSharp with m.Modular hidden(MULTIPLE_LINES_COMMENT, SINGLE_LINE_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore"
import "http://www.minim.games/modular"
import "http://www.minim.games/expressions"

generate csharp "http://www.minim.games/csharp"

Model:
	usings+=Using*
	procedures+=Procedure*;
Using:
	'using' name=QualifiedName ';';
QualifiedName:
	IDENTIFIER ('.' IDENTIFIER)*;

// Casts and lambdas
@Override
Expression:
	Ternary ({InlineAssignment.left=current}  kind=AssignmentKind right=Ternary)*;

@Override
UnaryMinus returns Expression:
	UnaryPlus | {UnaryMinus}  '-' expression=UnaryPlus
;

UnaryPlus returns Expression:
	PreDecrement | {UnaryPlus}  '+' expression=PreDecrement
;

PreDecrement returns Expression:
	PreIncrement | {PreDecrement}  '--' expression=PreIncrement;
	
PreIncrement returns Expression:
	Primary | {PreIncrement}  '++' expression=Primary;

	
Access: variables+=Variable ('.' variables+=Variable)*;

/*
Classifier:
	(Class | Structure | Enumeration);

Class:
	annotations+=Annotation*
	visibility=Visibility?
	sealed?='sealed'? static?='static' 'class' 
	name=TypeName (':' superTypes+=TypeName (SEPARATOR superTypes+=TypeName)*)?
	BEGIN
	members+=(Classifier|Field)*
	END;

Structure:
	annotations+=Annotation*
	visibility=Visibility?
	'struct' name=TypeName (':' superTypes+=TypeName (SEPARATOR superTypes+=TypeName)*)?
	BEGIN
	members+=(Classifier|Field)*
	END
;

Enumeration:
	annotations+=Annotation*
	visibility=Visibility?
	'enum' name=TypeName
	BEGIN
	members+=(Classifier|Field)*
	END
;

Annotation:
	'[' function=TypeName (OPEN parameters+=Expression (SEPARATOR parameters+=Expression)* CLOSE)? ']';

TypeName:
	name=QualifiedName ('<' generics+=QualifiedName (SEPARATOR generics+=QualifiedName)* '>')?;

Field:
	type=TypeName name=IDENTIFIER ';';

Argument:
	annotations+=Annotation* ref?='ref'? type=TypeName name=IDENTIFIER;

Method:
	override?='override'? (type=TypeName | implicit?='implicit' operator?='operator') name=IDENTIFIER ('<'
	generics+=TypeName (SEPARATOR generics+=TypeName)* '>')?
	OPEN (arguments+=Argument (SEPARATOR arguments+=Argument)*)? CLOSE
	BEGIN
	statements+=Statement*
	END;

@Override
Statement:
	For | Selection | Iteration | Call;

CAssignment:
	(var?='var' | type=TypeName)? access=CAccess (assignmentType=AssignmentKind expression=Expression | increment?='++' |
	decrement?='--')?;

Return:
	'return' expression=Expression;

@Override
Primary returns Expression:
	Access | Call | {Brackets} OPEN expression=Expression CLOSE;

For returns Block:
	{For}
	'for' OPEN initialization=Assignment ';' condition=Expression ';' increment=Assignment CLOSE
	BEGIN
	statements+=Statement*
	END;

InitializeVariable:
	name=IDENTIFIER '=' expression=Expression;

Lambda returns Block:
	{Lambda} OPEN arguments+=Argument (SEPARATOR arguments+=Argument)* CLOSE '=>' BEGIN statements+=Statement* END;


enum ClassifierKind:
	class | struct;

enum Visibility:
	public | private | protected | internal;

Index: identifier=IDENTIFIER  '[' (parameters+=Expression ( SEPARATOR parameters+=Expression)*)?  ']';

@Override
Variable: IdentifierLiteral|Call|Index;
*/


terminal MULTIPLE_LINES_COMMENT:
	'/*'->'*/';

terminal SINGLE_LINE_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;
 