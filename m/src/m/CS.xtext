grammar m.CS hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cs "http://www.CS.m"

File: 
	usings+=Using*
	types+=Member*
;

Using:
	'using' name=QualifiedName ';'
;

QualifiedName: names+=ID ('.' names+=ID)* ;

Type:	
	sealed?='sealed'?
	type=TypeEnum name=TypeName (':' superTypes+=TypeName (',' superTypes+=TypeName)*)? 
	'{'
		members+=Member*
	'}'
;

Member:
	annotations+=Annotation*
	visibility=Visibility static?='static'?
	value =(Type|Method|Field)	
;

Annotation:
	'[' function=TypeName ('(' parameters+=Expression (',' parameters+=Expression)* ')')? ']'
;

TypeName:
	name=QualifiedName ('<' generics+=QualifiedName (',' generics+=QualifiedName)* '>')?
;


    
Field: type=TypeName name=ID ';'
;
Argument: annotations+=Annotation* ref?='ref'? type=TypeName name=ID;

Method returns Block: {Method}
	override?='override'? (type=TypeName |implicit?='implicit' operator?='operator') name=ID ('<' generics+=TypeName (',' generics+=TypeName)* '>')?
	'(' (arguments+=Argument (',' arguments+=Argument)*)? ')'
	'{'
		commands+=Command*
	'}'
;

Command: For|If|While|Assignment';'|Return';';

Assignment: (var?='var'|type=TypeName)? access=Access (assignmentType=AssignmentType expression=Expression|increment?='++'|decrement?='--')?;

Return: 'return' expression=Expression;

Access: new?='new'? ref?='ref'? portions+=Portion ('.' portions+=Portion)*;

Portion:
	  {Label} name=ID
	| {MethodCall} name=ID ('<' generics+=TypeName '>')? '(' (expressions+=Expression (',' expressions+=Expression)*)? ')'
	| {Initialization} name=ID '{' (initializations+=InitializeVariable (',' initializations+=InitializeVariable)*)? '}'
	| {Indexing} name=ID '[' index=Expression ']'
;


For returns Block: {For}
	'for' '(' initialization=Assignment ';' condition=Expression ';' increment=Assignment ')'
	'{'
		commands+=Command*
	'}'
;

If returns Block: {If}
	'if' '(' expression=Expression ')'
	'{'
		commands+=Command*
	'}'
	elseIfs+=ElseIf*
	else=Else?
;
ElseIf returns Block: {ElseIf}
	'else' 'if' '(' expression=Expression ')'
	'{'
		commands+=Command*
	'}'
;
Else returns Block: {Else}
	'else'
	'{'
		commands+=Command*
	'}'
;

While returns Block:
	'while' '(' expression=Expression ')'
	'{'
		commands+=Command*
	'}'
;

Atomic returns Expression: 
	   Access
	| {Long} value=LONG
	| {Float} value=FLOAT
	| {String} value=STRING
;
InitializeVariable: name=ID '=' expression=Expression;

Lambda returns Block:
	{Lambda} '(' arguments+=Argument (',' arguments+=Argument)* ')' '=>' '{' commands+=Command* '}'
;
Expression:
	=>({Cast}'(' type=TypeName ')' expression=Boolean0) 
	| Lambda
	| Boolean0
;
Boolean0 returns Expression:
  Boolean1 ({Or.left=current} '||' right=Boolean1)*;
Boolean1 returns Expression:
  Boolean2 ({And.left=current} '&&' right=Boolean2)*;
Boolean2 returns Expression:
    Boolean3
  | {Not} '!' expression=Boolean3;
Boolean3 returns Expression:
	Boolean4 
;
Boolean4 returns Expression:
  Addition ({Comparison.left=current} type=RelationType right=Addition)?
;


Addition returns Expression:
  Multiplication (({Plus.left=current} '+'|{Minus.left=current} '-') right=Multiplication)*;
Multiplication returns Expression:
  Bitwise (({Times.left=current} '*'|{Divide.left=current}'/'|{Modulus.left=current}'%') right=Bitwise)*;
Bitwise returns Expression:
	Unary ({Bitwise.left=current} op=('&'|'|'|'~') right=Unary)*;
Unary returns Expression:
	Primary ({Increment.left=current} '++'|{Decrement.left=current}'--')?;
Primary returns Expression:
  Atomic | {Brackets} '(' expression=Expression ')';

enum TypeEnum: class|struct;
enum Visibility: public|private|protected|internal;
enum RelationType: over='>'|under='<'|equal='=='|notequal='!='|overorequal='>='|underorequal='<=';
enum AssignmentType: set='='|increase='+='|decrease='-='|multiply='*='|divide='/='|modulus='%='|and='&='|or='|=';

terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal LONG: '-'? '0'..'9'+;
terminal FLOAT: '-'? ('0'..'9')* '.' ('0'..'9')+ ('e' '-'? '0'..'9'+)?;

terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		;
terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal WS         : (' '|'\t'|'\r'|'\n')+;
 