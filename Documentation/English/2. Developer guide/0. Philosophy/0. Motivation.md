# Language properties

## Motivation

Problem I am trying to solve:
I know how to say it, I have said it, I know someone else can say it.

Why my problem is important to solve:
Who does it benefit? How much is it worth solving?

Plan B: What other solution do I have for my problem? Is plan B implemented?

Steps:
I can articulate the steps to solve my problem
I can point risks and unknowns in those steps
Examples:
I have used the project to solve actual problems
Completion:
I know what means to my project being complete
Statistics:
I know how to falsify my hypothesis.
Test with users my project and disprove my assumptions.

Efficiency:
I know how long it takes to run the project.
I know the minimal specs for my project to run
I know the dependencies of my project

Profile the generation
I know how to optimize the generation

Use case:
I know the most common use cases of the project
I know how programs written in my project look lke in real life
I know the acceptable range of programs that programmers can write in my project
I know what happens when someone goes out of that range
Watch users use the project
What is the part that they require most time for?
I know to debug when something fails, even without source code
I can apply data oriented:
I know what data I operate on
I know how I act with cache
This project gives back to the community.

## Properties

M is a DSL Compiled External C-like concrete syntax textual Scratch like visual
syntax Abstract syntax is a EMF model Strongly typed with implicit types Type
inferred and validated No null reference, no type conversion error, no infinite
loop Execution semantics: Game engine projects with assets Useful for non
programmers Turing complete Efficient compilation Efficient generated code,
native multi threaded Clean: Native support for DOD Full IDE support:

- Code completion
- Code generation
- Syntax Highlight
- Error markers
- Quick fixes
- Formatting
- Refactoring
- Labels
- Outline view
- Find uses
- Find definition
- Debugging

Small syntax Concise User defined abstractions: Files as libraries, functions
for reusability, prefabs possibly nested Fast and volatile development of
language No collections, all entities Big language scope: Most games M improves:

- Productivity: Less code to write and read
- Quality: No runtime errors, halts, multi threaded
- Communication and thinking: Familiar domain concepts, personalized views
- Platform support: Any platform with JVM any platform with Unity support
