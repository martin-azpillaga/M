# Responsability view (not allowed to step inside functions)

## VSCode extension

- Trigger server when workspace contains .Ⲙ files
- Trigger server when a Ⲙ file is opened
- Trigger server when restart command is called
- Restart command stops current connection and starts a new one

## Main package

- Communicate with client using LSP4J
- Keep projects in sync with file system
- Incrementally validate projects when files modify
- Trigger project generation when no errors found

### Main.java

- Create a language server
- Connect it to language client using stdin stdio
- Connect it to language client using socket 5007

### Server.java

- Start listening for language client notifications and requests

Connection lifetime events

- Initilize request: Send server capabilities + create a project foreach folder
- Initialized: Initialize project and publish created diagnostics
- Shutdown and Exit: Exit the program

File and folder synchronization

- Folder created: Create project and publish diagnostics
- Folder removed: Remove project
- File created: Signal all projects about file creation and publish diagnostics
- File removed: Signal all projects about file removal and publish diagnostics
- File modified:Signal all projects about file modification and publish diagnostics

Language services

- All: Unwrap lsp4j parameters into file and position + ask projects + wrap results for lsp4j

Privately

- Decode uris to file paths and encode them back
- Read from uris to pass text

Known issues

- ! Error if first project is removed ! Probably not in my code. If deleted first sends a shutdown request, if deleted second no shutdown request is sent.
- ! Sends modification messages to all projects but service messages to involved projects !
- ! Use uris directly instead of decoding them to file paths !

### Project.java

- When created: Detect all .Ⲙ files in root + trigger incremental build

## Validation

- ! Get the nodes from expressionGraph or build the local data in expressionGraph !

### Global validator

- On validation: validate locally
- Save validation results in memory
- Invalidate obsolete memory
- Validate project globally
- Add local problems
- Add undecidable and incompatible type problems
- Add all functions to game
- Add all well typed components to game
- Detect repeated functions and report error in each file
- return game data
- ! Garbage is created when clusters are merged !

### Local validator Parse + 2 pass validation

- Parse text into model and syntax errors
- Handle empty files
- ! Declare all functions and components beforehand !
- Declare variables of assignments and bindingBlocks
- Access values, components, functions and blocks.
- ! Assignments have special treatment as hardcoded functions !
- Push and pop value stack

- build resulting data in context -> expressionGraph
- Add syntax errors from parsing and return

### Context

- Create redefined, undefined and unused problems
- Bind expressions together for same variable, same component, same function, same type variable
- Type expressions for standard variable, standard component, standard function, standard block

### ExpressionGraph

- Maintain set of expression nodes. One per connected component.
- Convert expressions to ExpressionNodes
- Add bindings to each node of a binding
- Add a typing to a node with a reason
- ! Add connected component when typed if it has no bindings !
- ! When binding two nodes, if both are root, remove one; if none are root add one as root !

## Model

### Parser

- Inject MParser generated by Xtext
- Parse text and return results

# Flow

Main: connect to client via socket 5007
Server: start listening
Server: set capabilities
Server: Initialize projects
Project: Find .Ⲙ files in root folder
Project: Trigger incremental build for each

GlobalValidator: Validate new file content locally
LocalValidator: Parse file text
Parser: Use injected generated MParser and parse
LocalValidator: Declare all functions and components globally
LocalValidator: Go through the AST model

LocalValidator and Context and ExpressionGraph: Interplay
LocalValidator: Control context's defined variables stack by pushing and poping in blocks
LocalValidator: Declare new variables if foreach expression or assignment to variable
LocalValidator: Access variables, components, functions and blocks of context

3 reasons for redefined error:
Context: Redefined error if variable is in the standard library or is a user function or component.
Context: Redefined error if component is in the standard library or is a user function.
Context: Redefined error if function is in the standard library or is a previous user function.

5 reasons for undefined errors:
Context: Undefined error if variable is not standard nor in scope
Context: ! Undefined error if block is not standard !
Context: Undefined error if function parameter count does not match with standard or user function
Context: Undefined error if function does not exist

Context: ! Unused value error if variable was in stack not anymore and has not been accessed !

ExpressionGraph: Convert expression to expressionNode
