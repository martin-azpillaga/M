# Responsability view (not allowed to step inside functions)

## VSCode extension

- Trigger server main when workspace contains .Ⲙ files or Ⲙ.json files
- Restart command stops current connection and starts a new one
- Detect java 8+ installed in path by running java -version
- Show button to open webpage to download openjdk if not by using systems url opener
- Detect debugging mode by analyzing process' environment (set in .vscode/launch.json)
- If debugging server connects by socket
- If not debugging server connects by stdin and stdio by running packaged ls.jar file with java 8+
- Trigger document changed notifications for .M and M.json files
- Start language client and server
- Alert if file is opened outside of workspaces
- Trigger server main when opening a .Ⲙ file

## Main package

- Communicate with client using LSP4J
- Keep projects in sync with file system
- Incrementally validate projects when files modify
- Trigger project generation when no errors found

### Main.java

- Create a language server
- Connect it to language client using stdin stdio
- Connect it to language client using socket 5007
- Reconnect it to language client using socket 5007

### Server.java

Connection lifetime events

- Start listening for language client notifications and requests
- Initilize request: Send server capabilities + create a project foreach folder
- Initialized: Initialize project and publish created diagnostics
- Shutdown and Exit: Exit program with status 0

File and folder synchronization

- Folder created: Create project and publish diagnostics
- Folder removed: Remove project
- File created: Read file + Signal containing projects about file modification and publish diagnostics
- File removed: Signal containing projects about file removal and publish diagnostics
- File modified: Signal containing projects about file modification and publish diagnostics

Language services

- All: Unwrap lsp4j parameters into file and position + ask containing projects + wrap results for lsp4j

Privately

- Get containing projects of file by substring matching
- Read from uris to pass text

Known issues

- ! Error if first project is removed ! Probably not in my code. If deleted first sends a shutdown request, if deleted second no shutdown request is sent.
- ! Sends modification messages to all projects but service messages to involved projects !
- ! Use uris directly instead of decoding them to file paths !
- ! Whose responsability is to read all the files contained in a project: Project's or Server's? !

### Project.java

- Initialize: Detect all .Ⲙ files in root + validate changes + analyze result
- Delete file: Validate change + analyze result
- Modify file: Validate change + analyze result

- ! Say if it contains a file !
! Configuration file shouldn't be read every time the build is triggered but once and cached !
! Detect modifications to configuration file by making the server notify such changes !

Privately

- Analyze result: Read configuration file + generate project + return converted diagnostics
- Convert m.validation.problems to lsp4j.diagnostics

## Validation

- ! Get the nodes from expressionGraph or build the local data in expressionGraph !

### Global validator

- On validation: validate locally
- Save validation results in memory
- Invalidate obsolete memory
- Validate project globally
- Add local problems
- Add undecidable and incompatible type problems
- Add all functions to game
- Add all well typed components to game
- Detect repeated functions and report error in each file
- return game data
- ! Garbage is created when clusters are merged !

### Local validator Parse + 2 pass validation

- Parse text into model and syntax errors
- Handle empty files
- ! Declare all functions and components beforehand !
- Declare variables of assignments and bindingBlocks
- Access values, components, functions and blocks.
- ! Assignments have special treatment as hardcoded functions !
- Push and pop value stack

- build resulting data in context -> expressionGraph
- Add syntax errors from parsing and return

### Context

- Create redefined, undefined and unused problems
- Bind expressions together for same variable, same component, same function, same type variable
- Type expressions for standard variable, standard component, standard function, standard block

### ExpressionGraph

- Maintain set of expression nodes. One per connected component.
- Convert expressions to ExpressionNodes
- Add bindings to each node of a binding
- Add a typing to a node with a reason
- ! Add connected component when typed if it has no bindings !
- ! When binding two nodes, if both are root, remove one; if none are root add one as root !

## Model

### Parser

- Inject MParser generated by Xtext
- Parse text and return results

# Flow

Main: connect to client via socket 5007
Server: start listening
Server: set capabilities
Server: Initialize projects
Project: Find .Ⲙ files in root folder
Project: Trigger incremental build for each

GlobalValidator: Validate new file content locally
LocalValidator: Parse file text
Parser: Use injected generated MParser and parse
LocalValidator: Declare all functions and components globally
LocalValidator: Go through the AST model

LocalValidator and Context and ExpressionGraph: Interplay
LocalValidator: Control context's defined variables stack by pushing and poping in blocks
LocalValidator: Declare new variables if foreach expression or assignment to variable
LocalValidator: Access variables, components, functions and blocks of context

3 reasons for redefined error:
Context: Redefined error if variable is in the standard library or is a user function or component.
Context: Redefined error if component is in the standard library or is a user function.
Context: Redefined error if function is in the standard library or is a previous user function.

5 reasons for undefined errors:
Context: Undefined error if variable is not standard nor in scope
Context: ! Undefined error if block is not standard !
Context: Undefined error if function parameter count does not match with standard or user function
Context: Undefined error if function does not exist

Context: ! Unused value error if variable was in stack not anymore and has not been accessed !

ExpressionGraph: Convert expression to expressionNode
