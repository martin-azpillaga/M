# Source code

Under 100 files (54). Under 10k lines of code (7k). No comments (0). The code for the language server relies on the Xtext framework. It consists of two projects, m and m.ide. The project m holds all the information for running the compiler in headless mode. This includes the grammar specifying the lexer and parser rules, the validator, formatter, linker and code generators.
In fact, m consists of 7 languages and translations, one for each kind of supported file type. A language for JSON, XML, YAML, C#, and of course M and all its variants in different natural languages. Google's Guice dependency injection framework wires every component of the language. The IDE components like code completion, syntax highlighting, labels, quick fixes, outline view are in
the m.ide project independently from the execution platform. It's useful to have a m.ui project to test the functionality in a eclipse instance with a debugger attached to it.

Single sourcing: If certain code's structure logically depends on another code, it should get automatically generated. Example: Blockly block definitions depend on the grammars rules. Block definition files are automatically generated based on the grammars.

Parser: Terminals are single character and pairwise disjoint. Don't use hidden terminals. Don't use until token. Don't use syntactic predicates. Don't use backtracking. DataTypes combine terminals in the least information needed. Expressions follow Xtext guidelines for associativity and precedence. Full support for c# expressions in the base grammar. M grammar can override a rule to skip certain operators from the language. Unary minus operand acts on floats to make them negative (otherwise they are alway positive). Numbers in components can be negative because they use a different datatype rule which can include a minus sign (NUMBER vs FLOAT).

m/src

Generate.java: This main java file generates all the xtext infrastructure from the grammar files. To generate all the project files, first execute this main file. It will generate a bunch of files under m/src, m/src-gen, m.ide/src and m.ide/src-gen. It also generates a m.ui project to faster test the language server inside an eclipse application.
The easiest way to use eclipse with this project is to create a xtext project with the name m first with generic ide and eclipse plugin options selected, then download the project files to possibly override the existing ones. Execute generate.java as a java application and your eclipse project will be ready.

xRuntimeModule: Dependency injection wiring via Google guice modules. If the injection is already wired in AbstractLanguageRuntimeModule, the injection needs to be overridden, if it's not it must use def. Xtext has syntax sugar def bindIService(){ ClassName } OutputConfiguration is an example.

x.xtext: Grammar definitions. All independent. Limit terminals. More data rules and lastly parser rules. no backtracking, no semantic helpers.

converter/MyTerminalConverter: Used when terminal rules return something other than a EString. Defines how the conversion works in both directions.

errorHandling/XSyntaxErrorMessageProvider: Used when the parser throws an error to improve the error message considering the context.

xFormatter: dispatched functions to add white spaces when serializing a model.
AAlways try to use prepend to avoid conflicts, use grammar access to access non-keywords. Use literal keywords like ',' instead of grammarAccess ones for better maintainability.

LanguageGenerator:

Main.java: For headless execution. Depends on java JRE and the JAR built. Give it a file and it will parse it and generate it for you.

transformation: Each file is responsible of generating all files of a specific kind. First the type inference runs and now with the model and the types inferred the generator can generate all the artifacts. BuiltInLibrary translates names of built-in components for generating the same text in other languages. Some are legacy code. The ones that uses TextGenerator matter.

  No hybrid or pure distinction, use Hybrid.Rendering, Unity.Physics etc when they are ready and do the rest in Hybrid, as any professional would do nowadays.

  UnityGenerator UnityParser BlockGenerator BlockParser

xValidator: Rules to make extra assumptions true in the model. For example unique names.

Workflow.mwe2: Important. Generates all the artifacts. It defines the project structure and the fragments that each language cares about.

ide:

MyContentAssist extends IdeContentProposalProvider: For platform agnostic definition of content assist proposals.

MyLabelProvider extends SimpleNameLabelProvider: For platform agnostic definition of label names.

build.gradle: Gradle script to build the language server. It needs the reference to the mwe workflow file and it passes it the rootPath variable. It runs the workflow and generates a language server fat jar file in build folder.

## Generating Xtext artifacts

The first step to build the project is to generate all the xtext artifacts. The RunFragments.java file creates a xtext generator workflow and adds a standard language to it for each grammar file located in the m/src/m folder.

The standard languages include built in fragments to generate the grammar access, parser, emf model, generators, serializer etc. To all this we add a custom fragment called ContextualParserMessagesFragment which wires the ContextualParserMessages as the responsible for producing error messages when the parser finds one.

When we run the workflow, the generated dependency injection injectors AbstractXRuntimeModule.java wire all the fragments together. In particular, they wire the ISyntaxErrorMessageProvider interface to ContextualParserMessages.

## Using gradle

The build.gradle file defines two gradle tasks:

- runFragments: Runs the m.main.RunFragments.java file with the correct dependencies to generate the xtext artifacts.
- generateLanguageServer: Packages all the generated .class files and the dependencies in a fat jar file.

## Folder structure

The project has three root folders:

- .github: Contains all the automation tasks and their configuration files.

- Code: Contains all the java files and xtext grammars used to describe the language server and client.

- Documentation: Contains all the markdown files that explain the reasoning behind the code.

## Validation

There are three main types of checks:

- Uniqueness checks: Makes sure that there is a single element in the container with that specific name. Examples: unique component, unique entity, unique system.

- Existence checks: Makes sure that the specified cross reference exists. Examples: function call name exists, base of an entity exists.

- Acyclic checks: Makes sure that the dependencies are not cyclic. That means, if A depends on B, B can not depend on A etc. Examples: entity A has base B, entity B can not have base A. Similarly for 3-cycles and n-cycles. A depends on B, B depends on C, C can not depend on A.

- Typing checks: Makes sure that the variables have conformable types. Examples: Engine components have the correct type (Position must be a Float3 etc), Custom vector components have up to four entries, the sumands in an addition expression have the same type.
